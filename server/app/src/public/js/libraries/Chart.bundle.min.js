/*!
 * Chart.js v2.8.0
 * https://www.chartjs.org
 * (c) 2019 Chart.js Contributors
 * Released under the MIT License
 */
!(function (t, e) { typeof exports === "object" && typeof module !== "undefined" ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : t.Chart = e(); }(this, () => {
    const t = {
        rgb2hsl: e, rgb2hsv: i, rgb2hwb: n, rgb2cmyk: a, rgb2keyword: o, rgb2xyz: s, rgb2lab: l, rgb2lch(t) { return v(l(t)); }, hsl2rgb: u, hsl2hsv(t) { const e = t[0]; let i = t[1] / 100; let n = t[2] / 100; if (n === 0) return [0, 0, 0]; return [e, 100 * (2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i)), 100 * ((n + i) / 2)]; }, hsl2hwb(t) { return n(u(t)); }, hsl2cmyk(t) { return a(u(t)); }, hsl2keyword(t) { return o(u(t)); }, hsv2rgb: d, hsv2hsl(t) { let e; let i; const n = t[0]; const a = t[1] / 100; const r = t[2] / 100; return e = a * r, [n, 100 * (e = (e /= (i = (2 - a) * r) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)]; }, hsv2hwb(t) { return n(d(t)); }, hsv2cmyk(t) { return a(d(t)); }, hsv2keyword(t) { return o(d(t)); }, hwb2rgb: h, hwb2hsl(t) { return e(h(t)); }, hwb2hsv(t) { return i(h(t)); }, hwb2cmyk(t) { return a(h(t)); }, hwb2keyword(t) { return o(h(t)); }, cmyk2rgb: c, cmyk2hsl(t) { return e(c(t)); }, cmyk2hsv(t) { return i(c(t)); }, cmyk2hwb(t) { return n(c(t)); }, cmyk2keyword(t) { return o(c(t)); }, keyword2rgb: _, keyword2hsl(t) { return e(_(t)); }, keyword2hsv(t) { return i(_(t)); }, keyword2hwb(t) { return n(_(t)); }, keyword2cmyk(t) { return a(_(t)); }, keyword2lab(t) { return l(_(t)); }, keyword2xyz(t) { return s(_(t)); }, xyz2rgb: f, xyz2lab: m, xyz2lch(t) { return v(m(t)); }, lab2xyz: p, lab2rgb: y, lab2lch: v, lch2lab: x, lch2xyz(t) { return p(x(t)); }, lch2rgb(t) { return y(x(t)); },
    }; function e(t) { let e; let i; const n = t[0] / 255; const a = t[1] / 255; const r = t[2] / 255; const o = Math.min(n, a, r); const s = Math.max(n, a, r); const l = s - o; return s == o ? e = 0 : n == s ? e = (a - r) / l : a == s ? e = 2 + (r - n) / l : r == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (o + s) / 2, [e, 100 * (s == o ? 0 : i <= 0.5 ? l / (s + o) : l / (2 - s - o)), 100 * i]; } function i(t) { let e; let i; const n = t[0]; const a = t[1]; const r = t[2]; const o = Math.min(n, a, r); const s = Math.max(n, a, r); const l = s - o; return i = s == 0 ? 0 : l / s * 1e3 / 10, s == o ? e = 0 : n == s ? e = (a - r) / l : a == s ? e = 2 + (r - n) / l : r == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, s / 255 * 1e3 / 10]; } function n(t) { const i = t[0]; const n = t[1]; let a = t[2]; return [e(t)[0], 100 * (1 / 255 * Math.min(i, Math.min(n, a))), 100 * (a = 1 - 1 / 255 * Math.max(i, Math.max(n, a)))]; } function a(t) { let e; const i = t[0] / 255; const n = t[1] / 255; const a = t[2] / 255; return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - a))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * e]; } function o(t) { return w[JSON.stringify(t)]; } function s(t) { let e = t[0] / 255; let i = t[1] / 255; let n = t[2] / 255; return [100 * (0.4124 * (e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92) + 0.3576 * (i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92) + 0.1805 * (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92)), 100 * (0.2126 * e + 0.7152 * i + 0.0722 * n), 100 * (0.0193 * e + 0.1192 * i + 0.9505 * n)]; } function l(t) { const e = s(t); let i = e[0]; let n = e[1]; let a = e[2]; return n /= 100, a /= 108.883, i = (i /= 95.047) > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, [116 * (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (a = a > 0.008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))]; } function u(t) { let e; let i; let n; let a; let r; const o = t[0] / 360; const s = t[1] / 100; const l = t[2] / 100; if (s == 0) return [r = 255 * l, r, r]; e = 2 * l - (i = l < 0.5 ? l * (1 + s) : l + s - l * s), a = [0, 0, 0]; for (let u = 0; u < 3; u++)(n = o + 1 / 3 * -(u - 1)) < 0 && n++, n > 1 && n--, r = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, a[u] = 255 * r; return a; } function d(t) { const e = t[0] / 60; const i = t[1] / 100; let n = t[2] / 100; const a = Math.floor(e) % 6; const r = e - Math.floor(e); const o = 255 * n * (1 - i); const s = 255 * n * (1 - i * r); const l = 255 * n * (1 - i * (1 - r)); n *= 255; switch (a) { case 0: return [n, l, o]; case 1: return [s, n, o]; case 2: return [o, n, l]; case 3: return [o, s, n]; case 4: return [l, o, n]; case 5: return [n, o, s]; } } function h(t) { let e; let i; let n; let a; const o = t[0] / 360; let s = t[1] / 100; let l = t[2] / 100; const u = s + l; switch (u > 1 && (s /= u, l /= u), n = 6 * o - (e = Math.floor(6 * o)), (1 & e) != 0 && (n = 1 - n), a = s + n * ((i = 1 - l) - s), e) { default: case 6: case 0: r = i, g = a, b = s; break; case 1: r = a, g = i, b = s; break; case 2: r = s, g = i, b = a; break; case 3: r = s, g = a, b = i; break; case 4: r = a, g = s, b = i; break; case 5: r = i, g = s, b = a; } return [255 * r, 255 * g, 255 * b]; } function c(t) { const e = t[0] / 100; const i = t[1] / 100; const n = t[2] / 100; const a = t[3] / 100; return [255 * (1 - Math.min(1, e * (1 - a) + a)), 255 * (1 - Math.min(1, i * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a))]; } function f(t) { let e; let i; let n; const a = t[0] / 100; const r = t[1] / 100; const o = t[2] / 100; return i = -0.9689 * a + 1.8758 * r + 0.0415 * o, n = 0.0557 * a + -0.204 * r + 1.057 * o, e = (e = 3.2406 * a + -1.5372 * r + -0.4986 * o) > 0.0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055 : e *= 12.92, i = i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i *= 12.92, n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))]; } function m(t) { let e = t[0]; let i = t[1]; let n = t[2]; return i /= 100, n /= 108.883, e = (e /= 95.047) > 0.008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))]; } function p(t) { let e; let i; let n; let a; const r = t[0]; const o = t[1]; const s = t[2]; return r <= 8 ? a = (i = 100 * r / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * Math.pow((r + 16) / 116, 3), a = Math.pow(i / 100, 1 / 3)), [e = e / 95.047 <= 0.008856 ? e = 95.047 * (o / 500 + a - 16 / 116) / 7.787 : 95.047 * Math.pow(o / 500 + a, 3), i, n = n / 108.883 <= 0.008859 ? n = 108.883 * (a - s / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(a - s / 200, 3)]; } function v(t) { let e; const i = t[0]; const n = t[1]; const a = t[2]; return (e = 360 * Math.atan2(a, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + a * a), e]; } function y(t) { return f(p(t)); } function x(t) { let e; const i = t[0]; const n = t[1]; return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)]; } function _(t) { return k[t]; } var k = {
        aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
    }; var w = {}; for (const M in k)w[JSON.stringify(k[M])] = M; const S = function () { return new O(); }; for (const D in t) { S[`${D}Raw`] = (function (e) { return function (i) { return typeof i === "number" && (i = Array.prototype.slice.call(arguments)), t[e](i); }; }(D)); const C = /(\w+)2(\w+)/.exec(D); const P = C[1]; const T = C[2]; (S[P] = S[P] || {})[T] = S[D] = (function (e) { return function (i) { typeof i === "number" && (i = Array.prototype.slice.call(arguments)); const n = t[e](i); if (typeof n === "string" || void 0 === n) return n; for (let a = 0; a < n.length; a++)n[a] = Math.round(n[a]); return n; }; }(D)); } var O = function () { this.convs = {}; }; O.prototype.routeSpace = function (t, e) { let i = e[0]; return void 0 === i ? this.getValues(t) : (typeof i === "number" && (i = Array.prototype.slice.call(e)), this.setValues(t, i)); }, O.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this; }, O.prototype.getValues = function (t) { let e = this.convs[t]; if (!e) { const i = this.space; const n = this.convs[i]; e = S[i][t](n), this.convs[t] = e; } return e; }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach((t) => { O.prototype[t] = function (e) { return this.routeSpace(t, arguments); }; }); const I = S; const A = {
        aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
    }; const F = {
        getRgba: R, getHsla: L, getRgb(t) { const e = R(t); return e && e.slice(0, 3); }, getHsl(t) { const e = L(t); return e && e.slice(0, 3); }, getHwb: W, getAlpha(t) { let e = R(t); if (e) return e[3]; if (e = L(t)) return e[3]; if (e = W(t)) return e[3]; }, hexString(t, e) { var e = void 0 !== e && t.length === 3 ? e : t[3]; return `#${H(t[0])}${H(t[1])}${H(t[2])}${e >= 0 && e < 1 ? H(Math.round(255 * e)) : ""}`; }, rgbString(t, e) { if (e < 1 || t[3] && t[3] < 1) return Y(t, e); return `rgb(${t[0]}, ${t[1]}, ${t[2]})`; }, rgbaString: Y, percentString(t, e) { if (e < 1 || t[3] && t[3] < 1) return N(t, e); const i = Math.round(t[0] / 255 * 100); const n = Math.round(t[1] / 255 * 100); const a = Math.round(t[2] / 255 * 100); return `rgb(${i}%, ${n}%, ${a}%)`; }, percentaString: N, hslString(t, e) { if (e < 1 || t[3] && t[3] < 1) return z(t, e); return `hsl(${t[0]}, ${t[1]}%, ${t[2]}%)`; }, hslaString: z, hwbString(t, e) { void 0 === e && (e = void 0 !== t[3] ? t[3] : 1); return `hwb(${t[0]}, ${t[1]}%, ${t[2]}%${void 0 !== e && e !== 1 ? `, ${e}` : ""})`; }, keyword(t) { return E[t.slice(0, 3)]; },
    }; function R(t) { if (t) { let e = [0, 0, 0]; let i = 1; let n = t.match(/^#([a-fA-F0-9]{3,4})$/i); let a = ""; if (n) { a = (n = n[1])[3]; for (var r = 0; r < e.length; r++)e[r] = parseInt(n[r] + n[r], 16); a && (i = Math.round(parseInt(a + a, 16) / 255 * 100) / 100); } else if (n = t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)) { a = n[2], n = n[1]; for (r = 0; r < e.length; r++)e[r] = parseInt(n.slice(2 * r, 2 * r + 2), 16); a && (i = Math.round(parseInt(a, 16) / 255 * 100) / 100); } else if (n = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (r = 0; r < e.length; r++)e[r] = parseInt(n[r + 1]); i = parseFloat(n[4]); } else if (n = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (r = 0; r < e.length; r++)e[r] = Math.round(2.55 * parseFloat(n[r + 1])); i = parseFloat(n[4]); } else if (n = t.match(/(\w+)/)) { if (n[1] == "transparent") return [0, 0, 0, 0]; if (!(e = A[n[1]])) return; } for (r = 0; r < e.length; r++)e[r] = V(e[r], 0, 255); return i = i || i == 0 ? V(i, 0, 1) : 1, e[3] = i, e; } } function L(t) { if (t) { const e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { const i = parseFloat(e[4]); return [V(parseInt(e[1]), 0, 360), V(parseFloat(e[2]), 0, 100), V(parseFloat(e[3]), 0, 100), V(isNaN(i) ? 1 : i, 0, 1)]; } } } function W(t) { if (t) { const e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { const i = parseFloat(e[4]); return [V(parseInt(e[1]), 0, 360), V(parseFloat(e[2]), 0, 100), V(parseFloat(e[3]), 0, 100), V(isNaN(i) ? 1 : i, 0, 1)]; } } } function Y(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `rgba(${t[0]}, ${t[1]}, ${t[2]}, ${e})`; } function N(t, e) { return `rgba(${Math.round(t[0] / 255 * 100)}%, ${Math.round(t[1] / 255 * 100)}%, ${Math.round(t[2] / 255 * 100)}%, ${e || t[3] || 1})`; } function z(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `hsla(${t[0]}, ${t[1]}%, ${t[2]}%, ${e})`; } function V(t, e, i) { return Math.min(Math.max(e, t), i); } function H(t) { const e = t.toString(16).toUpperCase(); return e.length < 2 ? `0${e}` : e; } var E = {}; for (const B in A)E[A[B]] = B; var j = function (t) {
        return t instanceof j ? t : this instanceof j ? (this.valid = !1, this.values = {
            rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1,
        }, void (typeof t === "string" ? (e = F.getRgba(t)) ? this.setValues("rgb", e) : (e = F.getHsla(t)) ? this.setValues("hsl", e) : (e = F.getHwb(t)) && this.setValues("hwb", e) : typeof t === "object" && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new j(t); let e;
    }; j.prototype = {
        isValid() { return this.valid; }, rgb() { return this.setSpace("rgb", arguments); }, hsl() { return this.setSpace("hsl", arguments); }, hsv() { return this.setSpace("hsv", arguments); }, hwb() { return this.setSpace("hwb", arguments); }, cmyk() { return this.setSpace("cmyk", arguments); }, rgbArray() { return this.values.rgb; }, hslArray() { return this.values.hsl; }, hsvArray() { return this.values.hsv; }, hwbArray() { const t = this.values; return t.alpha !== 1 ? t.hwb.concat([t.alpha]) : t.hwb; }, cmykArray() { return this.values.cmyk; }, rgbaArray() { const t = this.values; return t.rgb.concat([t.alpha]); }, hslaArray() { const t = this.values; return t.hsl.concat([t.alpha]); }, alpha(t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this); }, red(t) { return this.setChannel("rgb", 0, t); }, green(t) { return this.setChannel("rgb", 1, t); }, blue(t) { return this.setChannel("rgb", 2, t); }, hue(t) { return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t); }, saturation(t) { return this.setChannel("hsl", 1, t); }, lightness(t) { return this.setChannel("hsl", 2, t); }, saturationv(t) { return this.setChannel("hsv", 1, t); }, whiteness(t) { return this.setChannel("hwb", 1, t); }, blackness(t) { return this.setChannel("hwb", 2, t); }, value(t) { return this.setChannel("hsv", 2, t); }, cyan(t) { return this.setChannel("cmyk", 0, t); }, magenta(t) { return this.setChannel("cmyk", 1, t); }, yellow(t) { return this.setChannel("cmyk", 2, t); }, black(t) { return this.setChannel("cmyk", 3, t); }, hexString() { return F.hexString(this.values.rgb); }, rgbString() { return F.rgbString(this.values.rgb, this.values.alpha); }, rgbaString() { return F.rgbaString(this.values.rgb, this.values.alpha); }, percentString() { return F.percentString(this.values.rgb, this.values.alpha); }, hslString() { return F.hslString(this.values.hsl, this.values.alpha); }, hslaString() { return F.hslaString(this.values.hsl, this.values.alpha); }, hwbString() { return F.hwbString(this.values.hwb, this.values.alpha); }, keyword() { return F.keyword(this.values.rgb, this.values.alpha); }, rgbNumber() { const t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2]; }, luminosity() { for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) { const n = t[i] / 255; e[i] = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4); } return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]; }, contrast(t) { const e = this.luminosity(); const i = t.luminosity(); return e > i ? (e + 0.05) / (i + 0.05) : (i + 0.05) / (e + 0.05); }, level(t) { const e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : ""; }, dark() { const t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128; }, light() { return !this.dark(); }, negate() { for (var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this; }, lighten(t) { const e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this; }, darken(t) { const e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this; }, saturate(t) { const e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this; }, desaturate(t) { const e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this; }, whiten(t) { const e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this; }, blacken(t) { const e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this; }, greyscale() { const t = this.values.rgb; const e = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2]; return this.setValues("rgb", [e, e, e]), this; }, clearer(t) { const e = this.values.alpha; return this.setValues("alpha", e - e * t), this; }, opaquer(t) { const e = this.values.alpha; return this.setValues("alpha", e + e * t), this; }, rotate(t) { const e = this.values.hsl; const i = (e[0] + t) % 360; return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this; }, mix(t, e) { const i = t; const n = void 0 === e ? 0.5 : e; const a = 2 * n - 1; const r = this.alpha() - i.alpha(); const o = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2; const s = 1 - o; return this.rgb(o * this.red() + s * i.red(), o * this.green() + s * i.green(), o * this.blue() + s * i.blue()).alpha(this.alpha() * n + i.alpha() * (1 - n)); }, toJSON() { return this.rgb(); }, clone() { let t; let e; const i = new j(); const n = this.values; const a = i.values; for (const r in n)n.hasOwnProperty(r) && (t = n[r], (e = {}.toString.call(t)) === "[object Array]" ? a[r] = t.slice(0) : e === "[object Number]" ? a[r] = t : console.error("unexpected color value:", t)); return i; },
    }, j.prototype.spaces = {
        rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"],
    }, j.prototype.maxes = {
        rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100],
    }, j.prototype.getValues = function (t) { for (var e = this.values, i = {}, n = 0; n < t.length; n++)i[t.charAt(n)] = e[t][n]; return e.alpha !== 1 && (i.a = e.alpha), i; }, j.prototype.setValues = function (t, e) { let i; let n; const a = this.values; const r = this.spaces; const o = this.maxes; let s = 1; if (this.valid = !0, t === "alpha")s = e; else if (e.length)a[t] = e.slice(0, t.length), s = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (i = 0; i < t.length; i++)a[t][i] = e[t.charAt(i)]; s = e.a; } else if (void 0 !== e[r[t][0]]) { const l = r[t]; for (i = 0; i < t.length; i++)a[t][i] = e[l[i]]; s = e.alpha; } if (a.alpha = Math.max(0, Math.min(1, void 0 === s ? a.alpha : s)), t === "alpha") return !1; for (i = 0; i < t.length; i++)n = Math.max(0, Math.min(o[t][i], a[t][i])), a[t][i] = Math.round(n); for (const u in r)u !== t && (a[u] = I[t][u](a[t])); return !0; }, j.prototype.setSpace = function (t, e) { let i = e[0]; return void 0 === i ? this.getValues(t) : (typeof i === "number" && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this); }, j.prototype.setChannel = function (t, e, i) { const n = this.values[t]; return void 0 === i ? n[e] : i === n[e] ? this : (n[e] = i, this.setValues(t, n), this); }, typeof window !== "undefined" && (window.Color = j); let U; const G = j; var q = {
        noop() {}, uid: (U = 0, function () { return U++; }), isNullOrUndef(t) { return t == null; }, isArray(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.substr(0, 7) === "[object" && e.substr(-6) === "Array]"; }, isObject(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]"; }, isFinite(t) { return (typeof t === "number" || t instanceof Number) && isFinite(t); }, valueOrDefault(t, e) { return void 0 === t ? e : t; }, valueAtIndexOrDefault(t, e, i) { return q.valueOrDefault(q.isArray(t) ? t[e] : t, i); }, callback(t, e, i) { if (t && typeof t.call === "function") return t.apply(i, e); }, each(t, e, i, n) { let a; let r; let o; if (q.isArray(t)) if (r = t.length, n) for (a = r - 1; a >= 0; a--)e.call(i, t[a], a); else for (a = 0; a < r; a++)e.call(i, t[a], a); else if (q.isObject(t)) for (r = (o = Object.keys(t)).length, a = 0; a < r; a++)e.call(i, t[o[a]], o[a]); }, arrayEquals(t, e) { let i; let n; let a; let r; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i) if (a = t[i], r = e[i], a instanceof Array && r instanceof Array) { if (!q.arrayEquals(a, r)) return !1; } else if (a !== r) return !1; return !0; }, clone(t) { if (q.isArray(t)) return t.map(q.clone); if (q.isObject(t)) { for (var e = {}, i = Object.keys(t), n = i.length, a = 0; a < n; ++a)e[i[a]] = q.clone(t[i[a]]); return e; } return t; }, _merger(t, e, i, n) { const a = e[t]; const r = i[t]; q.isObject(a) && q.isObject(r) ? q.merge(a, r, n) : e[t] = q.clone(r); }, _mergerIf(t, e, i) { const n = e[t]; const a = i[t]; q.isObject(n) && q.isObject(a) ? q.mergeIf(n, a) : e.hasOwnProperty(t) || (e[t] = q.clone(a)); }, merge(t, e, i) { let n; let a; let r; let o; let s; const l = q.isArray(e) ? e : [e]; const u = l.length; if (!q.isObject(t)) return t; for (n = (i = i || {}).merger || q._merger, a = 0; a < u; ++a) if (e = l[a], q.isObject(e)) for (s = 0, o = (r = Object.keys(e)).length; s < o; ++s)n(r[s], t, e, i); return t; }, mergeIf(t, e) { return q.merge(t, e, { merger: q._mergerIf }); }, extend(t) { for (let e = function (e, i) { t[i] = e; }, i = 1, n = arguments.length; i < n; ++i)q.each(arguments[i], e); return t; }, inherits(t) { const e = this; const i = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments); }; const n = function () { this.constructor = i; }; return n.prototype = e.prototype, i.prototype = new n(), i.extend = q.inherits, t && q.extend(i.prototype, t), i.__super__ = e.prototype, i; },
    }; const Z = q; q.callCallback = q.callback, q.indexOf = function (t, e, i) { return Array.prototype.indexOf.call(t, e, i); }, q.getValueOrDefault = q.valueOrDefault, q.getValueAtIndexOrDefault = q.valueAtIndexOrDefault; var $ = {
        linear(t) { return t; }, easeInQuad(t) { return t * t; }, easeOutQuad(t) { return -t * (t - 2); }, easeInOutQuad(t) { return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }, easeInCubic(t) { return t * t * t; }, easeOutCubic(t) { return (t -= 1) * t * t + 1; }, easeInOutCubic(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }, easeInQuart(t) { return t * t * t * t; }, easeOutQuart(t) { return -((t -= 1) * t * t * t - 1); }, easeInOutQuart(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }, easeInQuint(t) { return t * t * t * t * t; }, easeOutQuint(t) { return (t -= 1) * t * t * t * t + 1; }, easeInOutQuint(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }, easeInSine(t) { return 1 - Math.cos(t * (Math.PI / 2)); }, easeOutSine(t) { return Math.sin(t * (Math.PI / 2)); }, easeInOutSine(t) { return -0.5 * (Math.cos(Math.PI * t) - 1); }, easeInExpo(t) { return t === 0 ? 0 : Math.pow(2, 10 * (t - 1)); }, easeOutExpo(t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t); }, easeInOutExpo(t) { return t === 0 ? 0 : t === 1 ? 1 : (t /= 0.5) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * --t)); }, easeInCirc(t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1); }, easeOutCirc(t) { return Math.sqrt(1 - (t -= 1) * t); }, easeInOutCirc(t) { return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }, easeInElastic(t) { let e = 1.70158; let i = 0; let n = 1; return t === 0 ? 0 : t === 1 ? 1 : (i || (i = 0.3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)); }, easeOutElastic(t) { let e = 1.70158; let i = 0; let n = 1; return t === 0 ? 0 : t === 1 ? 1 : (i || (i = 0.3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1); }, easeInOutElastic(t) { let e = 1.70158; let i = 0; let n = 1; return t === 0 ? 0 : (t /= 0.5) == 2 ? 1 : (i || (i = 0.45), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -0.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * 0.5 + 1); }, easeInBack(t) { const e = 1.70158; return t * t * ((e + 1) * t - e); }, easeOutBack(t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1; }, easeInOutBack(t) { let e = 1.70158; return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2); }, easeInBounce(t) { return 1 - $.easeOutBounce(1 - t); }, easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }, easeInOutBounce(t) { return t < 0.5 ? 0.5 * $.easeInBounce(2 * t) : 0.5 * $.easeOutBounce(2 * t - 1) + 0.5; },
    }; const X = { effects: $ }; Z.easingEffects = $; const K = Math.PI; const J = K / 180; const Q = 2 * K; const tt = K / 2; const et = K / 4; const it = 2 * K / 3; const nt = {
        clear(t) { t.ctx.clearRect(0, 0, t.width, t.height); }, roundedRect(t, e, i, n, a, r) { if (r) { const o = Math.min(r, a / 2, n / 2); const s = e + o; const l = i + o; const u = e + n - o; const d = i + a - o; t.moveTo(e, l), s < u && l < d ? (t.arc(s, l, o, -K, -tt), t.arc(u, l, o, -tt, 0), t.arc(u, d, o, 0, tt), t.arc(s, d, o, tt, K)) : s < u ? (t.moveTo(s, i), t.arc(u, l, o, -tt, tt), t.arc(s, l, o, tt, K + tt)) : l < d ? (t.arc(s, l, o, -K, 0), t.arc(s, d, o, 0, K)) : t.arc(s, l, o, -K, K), t.closePath(), t.moveTo(e, i); } else t.rect(e, i, n, a); }, drawPoint(t, e, i, n, a, r) { let o; let s; let l; let u; let d; let h = (r || 0) * J; if (!e || typeof e !== "object" || (o = e.toString()) !== "[object HTMLImageElement]" && o !== "[object HTMLCanvasElement]") { if (!(isNaN(i) || i <= 0)) { switch (t.beginPath(), e) { default: t.arc(n, a, i, 0, Q), t.closePath(); break; case "triangle": t.moveTo(n + Math.sin(h) * i, a - Math.cos(h) * i), h += it, t.lineTo(n + Math.sin(h) * i, a - Math.cos(h) * i), h += it, t.lineTo(n + Math.sin(h) * i, a - Math.cos(h) * i), t.closePath(); break; case "rectRounded": u = i - (d = 0.516 * i), s = Math.cos(h + et) * u, l = Math.sin(h + et) * u, t.arc(n - s, a - l, d, h - K, h - tt), t.arc(n + l, a - s, d, h - tt, h), t.arc(n + s, a + l, d, h, h + tt), t.arc(n - l, a + s, d, h + tt, h + K), t.closePath(); break; case "rect": if (!r) { u = Math.SQRT1_2 * i, t.rect(n - u, a - u, 2 * u, 2 * u); break; }h += et; case "rectRot": s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + l, a - s), t.lineTo(n + s, a + l), t.lineTo(n - l, a + s), t.closePath(); break; case "crossRot": h += et; case "cross": s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n + l, a - s), t.lineTo(n - l, a + s); break; case "star": s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n + l, a - s), t.lineTo(n - l, a + s), h += et, s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n + l, a - s), t.lineTo(n - l, a + s); break; case "line": s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l); break; case "dash": t.moveTo(n, a), t.lineTo(n + Math.cos(h) * i, a + Math.sin(h) * i); }t.fill(), t.stroke(); } } else t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height); }, _isPointInArea(t, e) { return t.x > e.left - 1e-6 && t.x < e.right + 1e-6 && t.y > e.top - 1e-6 && t.y < e.bottom + 1e-6; }, clipArea(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip(); }, unclipArea(t) { t.restore(); }, lineTo(t, e, i, n) { const a = i.steppedLine; if (a) { if (a === "middle") { const r = (e.x + i.x) / 2; t.lineTo(r, n ? i.y : e.y), t.lineTo(r, n ? e.y : i.y); } else a === "after" && !n || a !== "after" && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y); t.lineTo(i.x, i.y); } else i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y); },
    }; const at = nt; Z.clear = nt.clear, Z.drawRoundedRectangle = function (t) { t.beginPath(), nt.roundedRect.apply(nt, arguments); }; const rt = { _set(t, e) { return Z.merge(this[t] || (this[t] = {}), e); } }; rt._set("global", {
        defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", defaultLineHeight: 1.2, showLines: !0,
    }); const ot = rt; const st = Z.valueOrDefault; const lt = {
        toLineHeight(t, e) { const i = (`${t}`).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!i || i[1] === "normal") return 1.2 * e; switch (t = +i[2], i[3]) { case "px": return t; case "%": t /= 100; } return e * t; },
        toPadding(t) {
            let e; let i; let n; let a; return Z.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, n = +t.bottom || 0, a = +t.left || 0) : e = i = n = a = +t || 0, {
                top: e, right: i, bottom: n, left: a, height: e + n, width: a + i,
            };
        },
        _parseFont(t) {
            const e = ot.global; const i = st(t.fontSize, e.defaultFontSize); const n = {
                family: st(t.fontFamily, e.defaultFontFamily), lineHeight: Z.options.toLineHeight(st(t.lineHeight, e.defaultLineHeight), i), size: i, style: st(t.fontStyle, e.defaultFontStyle), weight: null, string: "",
            }; return n.string = (function (t) { return !t || Z.isNullOrUndef(t.size) || Z.isNullOrUndef(t.family) ? null : `${(t.style ? `${t.style} ` : "") + (t.weight ? `${t.weight} ` : "") + t.size}px ${t.family}`; }(n)), n;
        },
        resolve(t, e, i) { let n; let a; let r; for (n = 0, a = t.length; n < a; ++n) if (void 0 !== (r = t[n]) && (void 0 !== e && typeof r === "function" && (r = r(e)), void 0 !== i && Z.isArray(r) && (r = r[i]), void 0 !== r)) return r; },
    }; const ut = Z; const dt = X; const ht = at; const ct = lt; ut.easing = dt, ut.canvas = ht, ut.options = ct; const ft = function (t) { ut.extend(this, t), this.initialize.apply(this, arguments); }; ut.extend(ft.prototype, {
        initialize() { this.hidden = !1; }, pivot() { const t = this; return t._view || (t._view = ut.clone(t._model)), t._start = {}, t; }, transition(t) { const e = this; const i = e._model; let n = e._start; let a = e._view; return i && t !== 1 ? (a || (a = e._view = {}), n || (n = e._start = {}), (function (t, e, i, n) { let a; let r; let o; let s; let l; let u; let d; let h; let c; const f = Object.keys(i); for (a = 0, r = f.length; a < r; ++a) if (u = i[o = f[a]], e.hasOwnProperty(o) || (e[o] = u), (s = e[o]) !== u && o[0] !== "_") { if (t.hasOwnProperty(o) || (t[o] = s), (d = typeof u) === typeof (l = t[o])) if (d === "string") { if ((h = G(l)).valid && (c = G(u)).valid) { e[o] = c.mix(h, n).rgbString(); continue; } } else if (ut.isFinite(l) && ut.isFinite(u)) { e[o] = l + (u - l) * n; continue; }e[o] = u; } }(n, a, i, t)), e) : (e._view = i, e._start = null, e); }, tooltipPosition() { return { x: this._model.x, y: this._model.y }; }, hasValue() { return ut.isNumber(this._model.x) && ut.isNumber(this._model.y); },
    }), ft.extend = ut.inherits; const gt = ft; const mt = gt.extend({
        chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null,
    }); const pt = mt; Object.defineProperty(mt.prototype, "animationObject", { get() { return this; } }), Object.defineProperty(mt.prototype, "chartInstance", { get() { return this.chart; }, set(t) { this.chart = t; } }), ot._set("global", {
        animation: {
            duration: 1e3, easing: "easeOutQuart", onProgress: ut.noop, onComplete: ut.noop,
        },
    }); const vt = {
        animations: [], request: null, addAnimation(t, e, i, n) { let a; let r; const o = this.animations; for (e.chart = t, e.startTime = Date.now(), e.duration = i, n || (t.animating = !0), a = 0, r = o.length; a < r; ++a) if (o[a].chart === t) return void (o[a] = e); o.push(e), o.length === 1 && this.requestAnimationFrame(); }, cancelAnimation(t) { const e = ut.findIndex(this.animations, (e) => e.chart === t); e !== -1 && (this.animations.splice(e, 1), t.animating = !1); }, requestAnimationFrame() { const t = this; t.request === null && (t.request = ut.requestAnimFrame.call(window, () => { t.request = null, t.startDigest(); })); }, startDigest() { this.advance(), this.animations.length > 0 && this.requestAnimationFrame(); }, advance() { for (var t, e, i, n, a = this.animations, r = 0; r < a.length;)e = (t = a[r]).chart, i = t.numSteps, n = Math.floor((Date.now() - t.startTime) / t.duration * i) + 1, t.currentStep = Math.min(n, i), ut.callback(t.render, [e, t], e), ut.callback(t.onAnimationProgress, [t], e), t.currentStep >= i ? (ut.callback(t.onAnimationComplete, [t], e), e.animating = !1, a.splice(r, 1)) : ++r; },
    }; const yt = ut.options.resolve; const bt = ["push", "pop", "shift", "splice", "unshift"]; function xt(t, e) { const i = t._chartjs; if (i) { const n = i.listeners; const a = n.indexOf(e); a !== -1 && n.splice(a, 1), n.length > 0 || (bt.forEach((e) => { delete t[e]; }), delete t._chartjs); } } const _t = function (t, e) { this.initialize(t, e); }; ut.extend(_t.prototype, {
        datasetElementType: null, dataElementType: null, initialize(t, e) { this.chart = t, this.index = e, this.linkScales(), this.addElements(); }, updateIndex(t) { this.index = t; }, linkScales() { const t = this; const e = t.getMeta(); const i = t.getDataset(); e.xAxisID !== null && e.xAxisID in t.chart.scales || (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id), e.yAxisID !== null && e.yAxisID in t.chart.scales || (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id); }, getDataset() { return this.chart.data.datasets[this.index]; }, getMeta() { return this.chart.getDatasetMeta(this.index); }, getScaleForId(t) { return this.chart.scales[t]; }, _getValueScaleId() { return this.getMeta().yAxisID; }, _getIndexScaleId() { return this.getMeta().xAxisID; }, _getValueScale() { return this.getScaleForId(this._getValueScaleId()); }, _getIndexScale() { return this.getScaleForId(this._getIndexScaleId()); }, reset() { this.update(!0); }, destroy() { this._data && xt(this._data, this); }, createMetaDataset() { const t = this.datasetElementType; return t && new t({ _chart: this.chart, _datasetIndex: this.index }); }, createMetaData(t) { const e = this.dataElementType; return e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t }); }, addElements() { let t; let e; const i = this.getMeta(); const n = this.getDataset().data || []; const a = i.data; for (t = 0, e = n.length; t < e; ++t)a[t] = a[t] || this.createMetaData(t); i.dataset = i.dataset || this.createMetaDataset(); }, addElementAndReset(t) { const e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0); }, buildOrUpdateElements() { let t; let e; const i = this; const n = i.getDataset(); const a = n.data || (n.data = []); i._data !== a && (i._data && xt(i._data, i), a && Object.isExtensible(a) && (e = i, (t = a)._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), bt.forEach((e) => { const i = `onData${e.charAt(0).toUpperCase()}${e.slice(1)}`; const n = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value() { const e = Array.prototype.slice.call(arguments); const a = n.apply(this, e); return ut.each(t._chartjs.listeners, (t) => { typeof t[i] === "function" && t[i].apply(t, e); }), a; } }); }))), i._data = a), i.resyncElements(); }, update: ut.noop, transition(t) { for (var e = this.getMeta(), i = e.data || [], n = i.length, a = 0; a < n; ++a)i[a].transition(t); e.dataset && e.dataset.transition(t); }, draw() { const t = this.getMeta(); const e = t.data || []; const i = e.length; let n = 0; for (t.dataset && t.dataset.draw(); n < i; ++n)e[n].draw(); }, removeHoverStyle(t) { ut.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle; }, setHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const i = t._index; const n = t.custom || {}; const a = t._model; const r = ut.getHoverColor; t.$previousStyle = { backgroundColor: a.backgroundColor, borderColor: a.borderColor, borderWidth: a.borderWidth }, a.backgroundColor = yt([n.hoverBackgroundColor, e.hoverBackgroundColor, r(a.backgroundColor)], void 0, i), a.borderColor = yt([n.hoverBorderColor, e.hoverBorderColor, r(a.borderColor)], void 0, i), a.borderWidth = yt([n.hoverBorderWidth, e.hoverBorderWidth, a.borderWidth], void 0, i); }, resyncElements() { const t = this.getMeta(); const e = this.getDataset().data; const i = t.data.length; const n = e.length; n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i); }, insertElements(t, e) { for (let i = 0; i < e; ++i) this.addElementAndReset(t + i); }, onDataPush() { const t = arguments.length; this.insertElements(this.getDataset().data.length - t, t); }, onDataPop() { this.getMeta().data.pop(); }, onDataShift() { this.getMeta().data.shift(); }, onDataSplice(t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2); }, onDataUnshift() { this.insertElements(0, arguments.length); },
    }), _t.extend = ut.inherits; const kt = _t; ot._set("global", {
        elements: {
            arc: {
                backgroundColor: ot.global.defaultColor, borderColor: "#fff", borderWidth: 2, borderAlign: "center",
            },
        },
    }); const wt = gt.extend({
        inLabelRange(t) { const e = this._view; return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2); }, inRange(t, e) { const i = this._view; if (i) { for (var n = ut.getAngleFromPoint(i, { x: t, y: e }), a = n.angle, r = n.distance, o = i.startAngle, s = i.endAngle; s < o;)s += 2 * Math.PI; for (;a > s;)a -= 2 * Math.PI; for (;a < o;)a += 2 * Math.PI; const l = a >= o && a <= s; const u = r >= i.innerRadius && r <= i.outerRadius; return l && u; } return !1; }, getCenterPoint() { const t = this._view; const e = (t.startAngle + t.endAngle) / 2; const i = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i }; }, getArea() { const t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2)); }, tooltipPosition() { const t = this._view; const e = t.startAngle + (t.endAngle - t.startAngle) / 2; const i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i }; }, draw() { let t; const e = this._chart.ctx; const i = this._view; const n = i.startAngle; const a = i.endAngle; const r = i.borderAlign === "inner" ? 0.33 : 0; e.save(), e.beginPath(), e.arc(i.x, i.y, Math.max(i.outerRadius - r, 0), n, a), e.arc(i.x, i.y, i.innerRadius, a, n, !0), e.closePath(), e.fillStyle = i.backgroundColor, e.fill(), i.borderWidth && (i.borderAlign === "inner" ? (e.beginPath(), t = r / i.outerRadius, e.arc(i.x, i.y, i.outerRadius, n - t, a + t), i.innerRadius > r ? (t = r / i.innerRadius, e.arc(i.x, i.y, i.innerRadius - r, a + t, n - t, !0)) : e.arc(i.x, i.y, r, a + Math.PI / 2, n - Math.PI / 2), e.closePath(), e.clip(), e.beginPath(), e.arc(i.x, i.y, i.outerRadius, n, a), e.arc(i.x, i.y, i.innerRadius, a, n, !0), e.closePath(), e.lineWidth = 2 * i.borderWidth, e.lineJoin = "round") : (e.lineWidth = i.borderWidth, e.lineJoin = "bevel"), e.strokeStyle = i.borderColor, e.stroke()), e.restore(); },
    }); const Mt = ut.valueOrDefault; const St = ot.global.defaultColor; ot._set("global", {
        elements: {
            line: {
                tension: 0.4, backgroundColor: St, borderWidth: 3, borderColor: St, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0,
            },
        },
    }); const Dt = gt.extend({ draw() { let t; let e; let i; let n; const a = this._view; const r = this._chart.ctx; const o = a.spanGaps; const s = this._children.slice(); const l = ot.global; const u = l.elements.line; let d = -1; for (this._loop && s.length && s.push(s[0]), r.save(), r.lineCap = a.borderCapStyle || u.borderCapStyle, r.setLineDash && r.setLineDash(a.borderDash || u.borderDash), r.lineDashOffset = Mt(a.borderDashOffset, u.borderDashOffset), r.lineJoin = a.borderJoinStyle || u.borderJoinStyle, r.lineWidth = Mt(a.borderWidth, u.borderWidth), r.strokeStyle = a.borderColor || l.defaultColor, r.beginPath(), d = -1, t = 0; t < s.length; ++t)e = s[t], i = ut.previousItem(s, t), n = e._view, t === 0 ? n.skip || (r.moveTo(n.x, n.y), d = t) : (i = d === -1 ? i : s[d], n.skip || (d !== t - 1 && !o || d === -1 ? r.moveTo(n.x, n.y) : ut.canvas.lineTo(r, i._view, e._view), d = t)); r.stroke(), r.restore(); } }); const Ct = ut.valueOrDefault; const Pt = ot.global.defaultColor; function Tt(t) { const e = this._view; return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius; }ot._set("global", {
        elements: {
            point: {
                radius: 3, pointStyle: "circle", backgroundColor: Pt, borderColor: Pt, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1,
            },
        },
    }); const Ot = gt.extend({
        inRange(t, e) { const i = this._view; return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2); }, inLabelRange: Tt, inXRange: Tt, inYRange(t) { const e = this._view; return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius; }, getCenterPoint() { const t = this._view; return { x: t.x, y: t.y }; }, getArea() { return Math.PI * Math.pow(this._view.radius, 2); }, tooltipPosition() { const t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth }; }, draw(t) { const e = this._view; const i = this._chart.ctx; const n = e.pointStyle; const a = e.rotation; const r = e.radius; const o = e.x; const s = e.y; const l = ot.global; const u = l.defaultColor; e.skip || (void 0 === t || ut.canvas._isPointInArea(e, t)) && (i.strokeStyle = e.borderColor || u, i.lineWidth = Ct(e.borderWidth, l.elements.point.borderWidth), i.fillStyle = e.backgroundColor || u, ut.canvas.drawPoint(i, n, r, o, s, a)); },
    }); const It = ot.global.defaultColor; function At(t) { return t && void 0 !== t.width; } function Ft(t) {
        let e; let i; let n; let a; let r; return At(t) ? (r = t.width / 2, e = t.x - r, i = t.x + r, n = Math.min(t.y, t.base), a = Math.max(t.y, t.base)) : (r = t.height / 2, e = Math.min(t.x, t.base), i = Math.max(t.x, t.base), n = t.y - r, a = t.y + r), {
            left: e, top: n, right: i, bottom: a,
        };
    } function Rt(t, e, i) { return t === e ? i : t === i ? e : t; } function Lt(t, e, i) {
        let n; let a; let r; let o; const s = t.borderWidth; const l = (function (t) { let e = t.borderSkipped; const i = {}; return e ? (t.horizontal ? t.base > t.x && (e = Rt(e, "left", "right")) : t.base < t.y && (e = Rt(e, "bottom", "top")), i[e] = !0, i) : i; }(t)); return ut.isObject(s) ? (n = +s.top || 0, a = +s.right || 0, r = +s.bottom || 0, o = +s.left || 0) : n = a = r = o = +s || 0, {
            t: l.top || n < 0 ? 0 : n > i ? i : n, r: l.right || a < 0 ? 0 : a > e ? e : a, b: l.bottom || r < 0 ? 0 : r > i ? i : r, l: l.left || o < 0 ? 0 : o > e ? e : o,
        };
    } function Wt(t, e, i) { const n = e === null; const a = i === null; const r = !(!t || n && a) && Ft(t); return r && (n || e >= r.left && e <= r.right) && (a || i >= r.top && i <= r.bottom); }ot._set("global", {
        elements: {
            rectangle: {
                backgroundColor: It, borderColor: It, borderSkipped: "bottom", borderWidth: 0,
            },
        },
    }); const Yt = gt.extend({
        draw() {
            const t = this._chart.ctx; const e = this._view; const i = (function (t) {
                const e = Ft(t); const i = e.right - e.left; const n = e.bottom - e.top; const a = Lt(t, i / 2, n / 2); return {
                    outer: {
                        x: e.left, y: e.top, w: i, h: n,
                    },
                    inner: {
                        x: e.left + a.l, y: e.top + a.t, w: i - a.l - a.r, h: n - a.t - a.b,
                    },
                };
            }(e)); const n = i.outer; const a = i.inner; t.fillStyle = e.backgroundColor, t.fillRect(n.x, n.y, n.w, n.h), n.w === a.w && n.h === a.h || (t.save(), t.beginPath(), t.rect(n.x, n.y, n.w, n.h), t.clip(), t.fillStyle = e.borderColor, t.rect(a.x, a.y, a.w, a.h), t.fill("evenodd"), t.restore());
        },
        height() { const t = this._view; return t.base - t.y; },
        inRange(t, e) { return Wt(this._view, t, e); },
        inLabelRange(t, e) { const i = this._view; return At(i) ? Wt(i, t, null) : Wt(i, null, e); },
        inXRange(t) { return Wt(this._view, t, null); },
        inYRange(t) { return Wt(this._view, null, t); },
        getCenterPoint() { let t; let e; const i = this._view; return At(i) ? (t = i.x, e = (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, e = i.y), { x: t, y: e }; },
        getArea() { const t = this._view; return At(t) ? t.width * Math.abs(t.y - t.base) : t.height * Math.abs(t.x - t.base); },
        tooltipPosition() { const t = this._view; return { x: t.x, y: t.y }; },
    }); const Nt = {}; const zt = wt; const Vt = Dt; const Ht = Ot; const Et = Yt; Nt.Arc = zt, Nt.Line = Vt, Nt.Point = Ht, Nt.Rectangle = Et; const Bt = ut.options.resolve; ot._set("bar", {
        hover: { mode: "label" },
        scales: {
            xAxes: [{
                type: "category", categoryPercentage: 0.8, barPercentage: 0.9, offset: !0, gridLines: { offsetGridLines: !0 },
            }],
            yAxes: [{ type: "linear" }],
        },
    }); const jt = kt.extend({
        dataElementType: Nt.Rectangle,
        initialize() { let t; kt.prototype.initialize.apply(this, arguments), (t = this.getMeta()).stack = this.getDataset().stack, t.bar = !0; },
        update(t) { let e; let i; const n = this.getMeta().data; for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e) this.updateElement(n[e], e, t); },
        updateElement(t, e, i) {
            const n = this; const a = n.getMeta(); const r = n.getDataset(); const o = n._resolveElementOptions(t, e); t._xScale = n.getScaleForId(a.xAxisID), t._yScale = n.getScaleForId(a.yAxisID), t._datasetIndex = n.index, t._index = e, t._model = {
                backgroundColor: o.backgroundColor, borderColor: o.borderColor, borderSkipped: o.borderSkipped, borderWidth: o.borderWidth, datasetLabel: r.label, label: n.chart.data.labels[e],
            }, n._updateElementGeometry(t, e, i), t.pivot();
        },
        _updateElementGeometry(t, e, i) { const n = this; const a = t._model; const r = n._getValueScale(); const o = r.getBasePixel(); const s = r.isHorizontal(); const l = n._ruler || n.getRuler(); const u = n.calculateBarValuePixels(n.index, e); const d = n.calculateBarIndexPixels(n.index, e, l); a.horizontal = s, a.base = i ? o : u.base, a.x = s ? i ? o : u.head : d.center, a.y = s ? d.center : i ? o : u.head, a.height = s ? d.size : void 0, a.width = s ? void 0 : d.size; },
        _getStacks(t) { let e; let i; const n = this.chart; const a = this._getIndexScale().options.stacked; const r = void 0 === t ? n.data.datasets.length : t + 1; const o = []; for (e = 0; e < r; ++e)(i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === a || !0 === a && o.indexOf(i.stack) === -1 || void 0 === a && (void 0 === i.stack || o.indexOf(i.stack) === -1)) && o.push(i.stack); return o; },
        getStackCount() { return this._getStacks().length; },
        getStackIndex(t, e) { const i = this._getStacks(t); const n = void 0 !== e ? i.indexOf(e) : -1; return n === -1 ? i.length - 1 : n; },
        getRuler() {
            let t; let e; const i = this._getIndexScale(); const n = this.getStackCount(); const a = this.index; const r = i.isHorizontal(); const o = r ? i.left : i.top; const s = o + (r ? i.width : i.height); const l = []; for (t = 0, e = this.getMeta().data.length; t < e; ++t)l.push(i.getPixelForValue(null, t, a)); return {
                min: ut.isNullOrUndef(i.options.barThickness) ? (function (t, e) { let i; let n; let a; let r; let o = t.isHorizontal() ? t.width : t.height; const s = t.getTicks(); for (a = 1, r = e.length; a < r; ++a)o = Math.min(o, Math.abs(e[a] - e[a - 1])); for (a = 0, r = s.length; a < r; ++a)n = t.getPixelForTick(a), o = a > 0 ? Math.min(o, n - i) : o, i = n; return o; }(i, l)) : -1, pixels: l, start: o, end: s, stackCount: n, scale: i,
            };
        },
        calculateBarValuePixels(t, e) {
            let i; let n; let a; let r; let o; let s; const l = this.chart; const u = this.getMeta(); const d = this._getValueScale(); const h = d.isHorizontal(); const c = l.data.datasets; const f = +d.getRightValue(c[t].data[e]); const g = d.options.minBarLength; const m = d.options.stacked; const p = u.stack; let v = 0; if (m || void 0 === m && void 0 !== p) for (i = 0; i < t; ++i)(n = l.getDatasetMeta(i)).bar && n.stack === p && n.controller._getValueScaleId() === d.id && l.isDatasetVisible(i) && (a = +d.getRightValue(c[i].data[e]), (f < 0 && a < 0 || f >= 0 && a > 0) && (v += a)); return r = d.getPixelForValue(v), s = (o = d.getPixelForValue(v + f)) - r, void 0 !== g && Math.abs(s) < g && (s = g, o = f >= 0 && !h || f < 0 && h ? r - g : r + g), {
                size: s, base: r, head: o, center: o + s / 2,
            };
        },
        calculateBarIndexPixels(t, e, i) {
            const n = i.scale.options; const a = n.barThickness === "flex" ? (function (t, e, i) { let n; const a = e.pixels; const r = a[t]; let o = t > 0 ? a[t - 1] : null; let s = t < a.length - 1 ? a[t + 1] : null; const l = i.categoryPercentage; return o === null && (o = r - (s === null ? e.end - e.start : s - r)), s === null && (s = r + r - o), n = r - (r - Math.min(o, s)) / 2 * l, { chunk: Math.abs(s - o) / 2 * l / e.stackCount, ratio: i.barPercentage, start: n }; }(e, i, n)) : (function (t, e, i) { let n; let a; const r = i.barThickness; const o = e.stackCount; const s = e.pixels[t]; return ut.isNullOrUndef(r) ? (n = e.min * i.categoryPercentage, a = i.barPercentage) : (n = r * o, a = 1), { chunk: n / o, ratio: a, start: s - n / 2 }; }(e, i, n)); const r = this.getStackIndex(t, this.getMeta().stack); const o = a.start + a.chunk * r + a.chunk / 2; const s = Math.min(ut.valueOrDefault(n.maxBarThickness, 1 / 0), a.chunk * a.ratio); return {
                base: o - s / 2, head: o + s / 2, center: o, size: s,
            };
        },
        draw() { const t = this.chart; const e = this._getValueScale(); const i = this.getMeta().data; const n = this.getDataset(); const a = i.length; let r = 0; for (ut.canvas.clipArea(t.ctx, t.chartArea); r < a; ++r)isNaN(e.getRightValue(n.data[r])) || i[r].draw(); ut.canvas.unclipArea(t.ctx); },
        _resolveElementOptions(t, e) {
            let i; let n; let a; const r = this.chart; const o = r.data.datasets[this.index]; const s = t.custom || {}; const l = r.options.elements.rectangle; const u = {}; const d = {
                chart: r, dataIndex: e, dataset: o, datasetIndex: this.index,
            }; const h = ["backgroundColor", "borderColor", "borderSkipped", "borderWidth"]; for (i = 0, n = h.length; i < n; ++i)u[a = h[i]] = Bt([s[a], o[a], l[a]], d, e); return u;
        },
    }); const Ut = ut.valueOrDefault; const Gt = ut.options.resolve; ot._set("bubble", { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title() { return ""; }, label(t, e) { const i = e.datasets[t.datasetIndex].label || ""; const n = e.datasets[t.datasetIndex].data[t.index]; return `${i}: (${t.xLabel}, ${t.yLabel}, ${n.r})`; } } } }); const qt = kt.extend({
        dataElementType: Nt.Point,
        update(t) { const e = this; const i = e.getMeta().data; ut.each(i, (i, n) => { e.updateElement(i, n, t); }); },
        updateElement(t, e, i) {
            const n = this; const a = n.getMeta(); const r = t.custom || {}; const o = n.getScaleForId(a.xAxisID); const s = n.getScaleForId(a.yAxisID); const l = n._resolveElementOptions(t, e); const u = n.getDataset().data[e]; const d = n.index; const h = i ? o.getPixelForDecimal(0.5) : o.getPixelForValue(typeof u === "object" ? u : NaN, e, d); const c = i ? s.getBasePixel() : s.getPixelForValue(u, e, d); t._xScale = o, t._yScale = s, t._options = l, t._datasetIndex = d, t._index = e, t._model = {
                backgroundColor: l.backgroundColor, borderColor: l.borderColor, borderWidth: l.borderWidth, hitRadius: l.hitRadius, pointStyle: l.pointStyle, rotation: l.rotation, radius: i ? 0 : l.radius, skip: r.skip || isNaN(h) || isNaN(c), x: h, y: c,
            }, t.pivot();
        },
        setHoverStyle(t) {
            const e = t._model; const i = t._options; const n = ut.getHoverColor; t.$previousStyle = {
                backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth, radius: e.radius,
            }, e.backgroundColor = Ut(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Ut(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Ut(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius;
        },
        _resolveElementOptions(t, e) {
            let i; let n; let a; const r = this.chart; const o = r.data.datasets[this.index]; const s = t.custom || {}; const l = r.options.elements.point; const u = o.data[e]; const d = {}; const h = {
                chart: r, dataIndex: e, dataset: o, datasetIndex: this.index,
            }; const c = ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"]; for (i = 0, n = c.length; i < n; ++i)d[a = c[i]] = Gt([s[a], o[a], l[a]], h, e); return d.radius = Gt([s.radius, u ? u.r : void 0, o.radius, l.radius], h, e), d;
        },
    }); const Zt = ut.options.resolve; const $t = ut.valueOrDefault; ot._set("doughnut", {
        animation: { animateRotate: !0, animateScale: !1 },
        hover: { mode: "single" },
        legendCallback(t) { const e = []; e.push(`<ul class="${t.id}-legend">`); const i = t.data; const n = i.datasets; const a = i.labels; if (n.length) for (let r = 0; r < n[0].data.length; ++r)e.push(`<li><span style="background-color:${n[0].backgroundColor[r]}"></span>`), a[r] && e.push(a[r]), e.push("</li>"); return e.push("</ul>"), e.join(""); },
        legend: {
            labels: {
                generateLabels(t) {
                    const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map((i, n) => {
                        const a = t.getDatasetMeta(0); const r = e.datasets[0]; const o = a.data[n]; const s = o && o.custom || {}; const l = t.options.elements.arc; return {
                            text: i, fillStyle: Zt([s.backgroundColor, r.backgroundColor, l.backgroundColor], void 0, n), strokeStyle: Zt([s.borderColor, r.borderColor, l.borderColor], void 0, n), lineWidth: Zt([s.borderWidth, r.borderWidth, l.borderWidth], void 0, n), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n,
                        };
                    }) : [];
                },
            },
            onClick(t, e) { let i; let n; let a; const r = e.index; const o = this.chart; for (i = 0, n = (o.data.datasets || []).length; i < n; ++i)(a = o.getDatasetMeta(i)).data[r] && (a.data[r].hidden = !a.data[r].hidden); o.update(); },
        },
        cutoutPercentage: 50,
        rotation: -0.5 * Math.PI,
        circumference: 2 * Math.PI,
        tooltips: { callbacks: { title() { return ""; }, label(t, e) { let i = e.labels[t.index]; const n = `: ${e.datasets[t.datasetIndex].data[t.index]}`; return ut.isArray(i) ? (i = i.slice())[0] += n : i += n, i; } } },
    }); const Xt = kt.extend({
        dataElementType: Nt.Arc,
        linkScales: ut.noop,
        getRingIndex(t) { for (var e = 0, i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && ++e; return e; },
        update(t) { let e; let i; const n = this; const a = n.chart; const r = a.chartArea; const o = a.options; const s = r.right - r.left; const l = r.bottom - r.top; let u = Math.min(s, l); let d = { x: 0, y: 0 }; const h = n.getMeta(); const c = h.data; const f = o.cutoutPercentage; const g = o.circumference; const m = n._getRingWeight(n.index); if (g < 2 * Math.PI) { let p = o.rotation % (2 * Math.PI); const v = (p += 2 * Math.PI * (p >= Math.PI ? -1 : p < -Math.PI ? 1 : 0)) + g; const y = { x: Math.cos(p), y: Math.sin(p) }; const b = { x: Math.cos(v), y: Math.sin(v) }; const x = p <= 0 && v >= 0 || p <= 2 * Math.PI && 2 * Math.PI <= v; const _ = p <= 0.5 * Math.PI && 0.5 * Math.PI <= v || p <= 2.5 * Math.PI && 2.5 * Math.PI <= v; const k = p <= -Math.PI && -Math.PI <= v || p <= Math.PI && Math.PI <= v; const w = p <= 0.5 * -Math.PI && 0.5 * -Math.PI <= v || p <= 1.5 * Math.PI && 1.5 * Math.PI <= v; const M = f / 100; const S = { x: k ? -1 : Math.min(y.x * (y.x < 0 ? 1 : M), b.x * (b.x < 0 ? 1 : M)), y: w ? -1 : Math.min(y.y * (y.y < 0 ? 1 : M), b.y * (b.y < 0 ? 1 : M)) }; const D = { x: x ? 1 : Math.max(y.x * (y.x > 0 ? 1 : M), b.x * (b.x > 0 ? 1 : M)), y: _ ? 1 : Math.max(y.y * (y.y > 0 ? 1 : M), b.y * (b.y > 0 ? 1 : M)) }; const C = { width: 0.5 * (D.x - S.x), height: 0.5 * (D.y - S.y) }; u = Math.min(s / C.width, l / C.height), d = { x: -0.5 * (D.x + S.x), y: -0.5 * (D.y + S.y) }; } for (e = 0, i = c.length; e < i; ++e)c[e]._options = n._resolveElementOptions(c[e], e); for (a.borderWidth = n.getMaxBorderWidth(), a.outerRadius = Math.max((u - a.borderWidth) / 2, 0), a.innerRadius = Math.max(f ? a.outerRadius / 100 * f : 0, 0), a.radiusLength = (a.outerRadius - a.innerRadius) / (n._getVisibleDatasetWeightTotal() || 1), a.offsetX = d.x * a.outerRadius, a.offsetY = d.y * a.outerRadius, h.total = n.calculateTotal(), n.outerRadius = a.outerRadius - a.radiusLength * n._getRingWeightOffset(n.index), n.innerRadius = Math.max(n.outerRadius - a.radiusLength * m, 0), e = 0, i = c.length; e < i; ++e)n.updateElement(c[e], e, t); },
        updateElement(t, e, i) {
            const n = this; const a = n.chart; const r = a.chartArea; const o = a.options; const s = o.animation; const l = (r.left + r.right) / 2; const u = (r.top + r.bottom) / 2; const d = o.rotation; const h = o.rotation; const c = n.getDataset(); const f = i && s.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(c.data[e]) * (o.circumference / (2 * Math.PI)); const g = i && s.animateScale ? 0 : n.innerRadius; const m = i && s.animateScale ? 0 : n.outerRadius; const p = t._options || {}; ut.extend(t, {
                _datasetIndex: n.index,
                _index: e,
                _model: {
                    backgroundColor: p.backgroundColor, borderColor: p.borderColor, borderWidth: p.borderWidth, borderAlign: p.borderAlign, x: l + a.offsetX, y: u + a.offsetY, startAngle: d, endAngle: h, circumference: f, outerRadius: m, innerRadius: g, label: ut.valueAtIndexOrDefault(c.label, e, a.data.labels[e]),
                },
            }); const v = t._model; i && s.animateRotate || (v.startAngle = e === 0 ? o.rotation : n.getMeta().data[e - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot();
        },
        calculateTotal() { let t; const e = this.getDataset(); const i = this.getMeta(); let n = 0; return ut.each(i.data, (i, a) => { t = e.data[a], isNaN(t) || i.hidden || (n += Math.abs(t)); }), n; },
        calculateCircumference(t) { const e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0; },
        getMaxBorderWidth(t) { let e; let i; let n; let a; let r; let o; let s; let l; let u = 0; const d = this.chart; if (!t) for (e = 0, i = d.data.datasets.length; e < i; ++e) if (d.isDatasetVisible(e)) { t = (n = d.getDatasetMeta(e)).data, e !== this.index && (r = n.controller); break; } if (!t) return 0; for (e = 0, i = t.length; e < i; ++e)a = t[e], (o = r ? r._resolveElementOptions(a, e) : a._options).borderAlign !== "inner" && (s = o.borderWidth, u = (l = o.hoverBorderWidth) > (u = s > u ? s : u) ? l : u); return u; },
        setHoverStyle(t) { const e = t._model; const i = t._options; const n = ut.getHoverColor; t.$previousStyle = { backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth }, e.backgroundColor = $t(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = $t(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = $t(i.hoverBorderWidth, i.borderWidth); },
        _resolveElementOptions(t, e) {
            let i; let n; let a; const r = this.chart; const o = this.getDataset(); const s = t.custom || {}; const l = r.options.elements.arc; const u = {}; const d = {
                chart: r, dataIndex: e, dataset: o, datasetIndex: this.index,
            }; const h = ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"]; for (i = 0, n = h.length; i < n; ++i)u[a = h[i]] = Zt([s[a], o[a], l[a]], d, e); return u;
        },
        _getRingWeightOffset(t) { for (var e = 0, i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i)); return e; },
        _getRingWeight(t) { return Math.max($t(this.chart.data.datasets[t].weight, 1), 0); },
        _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length); },
    }); ot._set("horizontalBar", {
        hover: { mode: "index", axis: "y" },
        scales: {
            xAxes: [{ type: "linear", position: "bottom" }],
            yAxes: [{
                type: "category", position: "left", categoryPercentage: 0.8, barPercentage: 0.9, offset: !0, gridLines: { offsetGridLines: !0 },
            }],
        },
        elements: { rectangle: { borderSkipped: "left" } },
        tooltips: { mode: "index", axis: "y" },
    }); const Kt = jt.extend({ _getValueScaleId() { return this.getMeta().xAxisID; }, _getIndexScaleId() { return this.getMeta().yAxisID; } }); const Jt = ut.valueOrDefault; const Qt = ut.options.resolve; const te = ut.canvas._isPointInArea; function ee(t, e) { return Jt(t.showLine, e.showLines); }ot._set("line", {
        showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] },
    }); const ie = kt.extend({
        datasetElementType: Nt.Line,
        dataElementType: Nt.Point,
        update(t) { let e; let i; const n = this; const a = n.getMeta(); const r = a.dataset; const o = a.data || []; const s = n.getScaleForId(a.yAxisID); const l = n.getDataset(); const u = ee(l, n.chart.options); for (u && (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), r._scale = s, r._datasetIndex = n.index, r._children = o, r._model = n._resolveLineOptions(r), r.pivot()), e = 0, i = o.length; e < i; ++e)n.updateElement(o[e], e, t); for (u && r._model.tension !== 0 && n.updateBezierControlPoints(), e = 0, i = o.length; e < i; ++e)o[e].pivot(); },
        updateElement(t, e, i) {
            let n; let a; const r = this; const o = r.getMeta(); const s = t.custom || {}; const l = r.getDataset(); const u = r.index; const d = l.data[e]; const h = r.getScaleForId(o.yAxisID); const c = r.getScaleForId(o.xAxisID); const f = o.dataset._model; const g = r._resolvePointOptions(t, e); n = c.getPixelForValue(typeof d === "object" ? d : NaN, e, u), a = i ? h.getBasePixel() : r.calculatePointY(d, e, u), t._xScale = c, t._yScale = h, t._options = g, t._datasetIndex = u, t._index = e, t._model = {
                x: n, y: a, skip: s.skip || isNaN(n) || isNaN(a), radius: g.radius, pointStyle: g.pointStyle, rotation: g.rotation, backgroundColor: g.backgroundColor, borderColor: g.borderColor, borderWidth: g.borderWidth, tension: Jt(s.tension, f ? f.tension : 0), steppedLine: !!f && f.steppedLine, hitRadius: g.hitRadius,
            };
        },
        _resolvePointOptions(t, e) {
            let i; let n; let a; const r = this.chart; const o = r.data.datasets[this.index]; const s = t.custom || {}; const l = r.options.elements.point; const u = {}; const d = {
                chart: r, dataIndex: e, dataset: o, datasetIndex: this.index,
            }; const h = {
                backgroundColor: "pointBackgroundColor", borderColor: "pointBorderColor", borderWidth: "pointBorderWidth", hitRadius: "pointHitRadius", hoverBackgroundColor: "pointHoverBackgroundColor", hoverBorderColor: "pointHoverBorderColor", hoverBorderWidth: "pointHoverBorderWidth", hoverRadius: "pointHoverRadius", pointStyle: "pointStyle", radius: "pointRadius", rotation: "pointRotation",
            }; const c = Object.keys(h); for (i = 0, n = c.length; i < n; ++i)u[a = c[i]] = Qt([s[a], o[h[a]], o[a], l[a]], d, e); return u;
        },
        _resolveLineOptions(t) { let e; let i; let n; const a = this.chart; const r = a.data.datasets[this.index]; const o = t.custom || {}; const s = a.options; const l = s.elements.line; const u = {}; const d = ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill", "cubicInterpolationMode"]; for (e = 0, i = d.length; e < i; ++e)u[n = d[e]] = Qt([o[n], r[n], l[n]]); return u.spanGaps = Jt(r.spanGaps, s.spanGaps), u.tension = Jt(r.lineTension, l.tension), u.steppedLine = Qt([o.steppedLine, r.steppedLine, l.stepped]), u; },
        calculatePointY(t, e, i) { let n; let a; let r; const o = this.chart; const s = this.getMeta(); const l = this.getScaleForId(s.yAxisID); let u = 0; let d = 0; if (l.options.stacked) { for (n = 0; n < i; n++) if (a = o.data.datasets[n], (r = o.getDatasetMeta(n)).type === "line" && r.yAxisID === l.id && o.isDatasetVisible(n)) { const h = Number(l.getRightValue(a.data[e])); h < 0 ? d += h || 0 : u += h || 0; } const c = Number(l.getRightValue(t)); return c < 0 ? l.getPixelForValue(d + c) : l.getPixelForValue(u + c); } return l.getPixelForValue(t); },
        updateBezierControlPoints() { let t; let e; let i; let n; const a = this.chart; const r = this.getMeta(); const o = r.dataset._model; const s = a.chartArea; let l = r.data || []; function u(t, e, i) { return Math.max(Math.min(t, i), e); } if (o.spanGaps && (l = l.filter((t) => !t._model.skip)), o.cubicInterpolationMode === "monotone")ut.splineCurveMonotone(l); else for (t = 0, e = l.length; t < e; ++t)i = l[t]._model, n = ut.splineCurve(ut.previousItem(l, t)._model, i, ut.nextItem(l, t)._model, o.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y; if (a.options.elements.line.capBezierPoints) for (t = 0, e = l.length; t < e; ++t)i = l[t]._model, te(i, s) && (t > 0 && te(l[t - 1]._model, s) && (i.controlPointPreviousX = u(i.controlPointPreviousX, s.left, s.right), i.controlPointPreviousY = u(i.controlPointPreviousY, s.top, s.bottom)), t < l.length - 1 && te(l[t + 1]._model, s) && (i.controlPointNextX = u(i.controlPointNextX, s.left, s.right), i.controlPointNextY = u(i.controlPointNextY, s.top, s.bottom))); },
        draw() {
            let t; const e = this.chart; const i = this.getMeta(); const n = i.data || []; const a = e.chartArea; const r = n.length; let o = 0; for (ee(this.getDataset(), e.options) && (t = (i.dataset._model.borderWidth || 0) / 2, ut.canvas.clipArea(e.ctx, {
                left: a.left, right: a.right, top: a.top - t, bottom: a.bottom + t,
            }), i.dataset.draw(), ut.canvas.unclipArea(e.ctx)); o < r; ++o)n[o].draw(a);
        },
        setHoverStyle(t) {
            const e = t._model; const i = t._options; const n = ut.getHoverColor; t.$previousStyle = {
                backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth, radius: e.radius,
            }, e.backgroundColor = Jt(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Jt(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Jt(i.hoverBorderWidth, i.borderWidth), e.radius = Jt(i.hoverRadius, i.radius);
        },
    }); const ne = ut.options.resolve; ot._set("polarArea", {
        scale: {
            type: "radialLinear", angleLines: { display: !1 }, gridLines: { circular: !0 }, pointLabels: { display: !1 }, ticks: { beginAtZero: !0 },
        },
        animation: { animateRotate: !0, animateScale: !0 },
        startAngle: -0.5 * Math.PI,
        legendCallback(t) { const e = []; e.push(`<ul class="${t.id}-legend">`); const i = t.data; const n = i.datasets; const a = i.labels; if (n.length) for (let r = 0; r < n[0].data.length; ++r)e.push(`<li><span style="background-color:${n[0].backgroundColor[r]}"></span>`), a[r] && e.push(a[r]), e.push("</li>"); return e.push("</ul>"), e.join(""); },
        legend: {
            labels: {
                generateLabels(t) {
                    const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map((i, n) => {
                        const a = t.getDatasetMeta(0); const r = e.datasets[0]; const o = a.data[n].custom || {}; const s = t.options.elements.arc; return {
                            text: i, fillStyle: ne([o.backgroundColor, r.backgroundColor, s.backgroundColor], void 0, n), strokeStyle: ne([o.borderColor, r.borderColor, s.borderColor], void 0, n), lineWidth: ne([o.borderWidth, r.borderWidth, s.borderWidth], void 0, n), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n,
                        };
                    }) : [];
                },
            },
            onClick(t, e) { let i; let n; let a; const r = e.index; const o = this.chart; for (i = 0, n = (o.data.datasets || []).length; i < n; ++i)(a = o.getDatasetMeta(i)).data[r].hidden = !a.data[r].hidden; o.update(); },
        },
        tooltips: { callbacks: { title() { return ""; }, label(t, e) { return `${e.labels[t.index]}: ${t.yLabel}`; } } },
    }); const ae = kt.extend({
        dataElementType: Nt.Arc,
        linkScales: ut.noop,
        update(t) { let e; let i; let n; const a = this; const r = a.getDataset(); const o = a.getMeta(); let s = a.chart.options.startAngle || 0; const l = a._starts = []; const u = a._angles = []; const d = o.data; for (a._updateRadius(), o.count = a.countVisibleElements(), e = 0, i = r.data.length; e < i; e++)l[e] = s, n = a._computeAngle(e), u[e] = n, s += n; for (e = 0, i = d.length; e < i; ++e)d[e]._options = a._resolveElementOptions(d[e], e), a.updateElement(d[e], e, t); },
        _updateRadius() { const t = this; const e = t.chart; const i = e.chartArea; const n = e.options; const a = Math.min(i.right - i.left, i.bottom - i.top); e.outerRadius = Math.max(a / 2, 0), e.innerRadius = Math.max(n.cutoutPercentage ? e.outerRadius / 100 * n.cutoutPercentage : 1, 0), e.radiusLength = (e.outerRadius - e.innerRadius) / e.getVisibleDatasetCount(), t.outerRadius = e.outerRadius - e.radiusLength * t.index, t.innerRadius = t.outerRadius - e.radiusLength; },
        updateElement(t, e, i) {
            const n = this; const a = n.chart; const r = n.getDataset(); const o = a.options; const s = o.animation; const l = a.scale; const u = a.data.labels; const d = l.xCenter; const h = l.yCenter; const c = o.startAngle; const f = t.hidden ? 0 : l.getDistanceFromCenterForValue(r.data[e]); const g = n._starts[e]; const m = g + (t.hidden ? 0 : n._angles[e]); const p = s.animateScale ? 0 : l.getDistanceFromCenterForValue(r.data[e]); const v = t._options || {}; ut.extend(t, {
                _datasetIndex: n.index,
                _index: e,
                _scale: l,
                _model: {
                    backgroundColor: v.backgroundColor, borderColor: v.borderColor, borderWidth: v.borderWidth, borderAlign: v.borderAlign, x: d, y: h, innerRadius: 0, outerRadius: i ? p : f, startAngle: i && s.animateRotate ? c : g, endAngle: i && s.animateRotate ? c : m, label: ut.valueAtIndexOrDefault(u, e, u[e]),
                },
            }), t.pivot();
        },
        countVisibleElements() { const t = this.getDataset(); const e = this.getMeta(); let i = 0; return ut.each(e.data, (e, n) => { isNaN(t.data[n]) || e.hidden || i++; }), i; },
        setHoverStyle(t) { const e = t._model; const i = t._options; const n = ut.getHoverColor; const a = ut.valueOrDefault; t.$previousStyle = { backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth }, e.backgroundColor = a(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = a(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = a(i.hoverBorderWidth, i.borderWidth); },
        _resolveElementOptions(t, e) {
            let i; let n; let a; const r = this.chart; const o = this.getDataset(); const s = t.custom || {}; const l = r.options.elements.arc; const u = {}; const d = {
                chart: r, dataIndex: e, dataset: o, datasetIndex: this.index,
            }; const h = ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"]; for (i = 0, n = h.length; i < n; ++i)u[a = h[i]] = ne([s[a], o[a], l[a]], d, e); return u;
        },
        _computeAngle(t) {
            const e = this; const i = this.getMeta().count; const n = e.getDataset(); const a = e.getMeta(); if (isNaN(n.data[t]) || a.data[t].hidden) return 0; const r = {
                chart: e.chart, dataIndex: t, dataset: n, datasetIndex: e.index,
            }; return ne([e.chart.options.elements.arc.angle, 2 * Math.PI / i], r, t);
        },
    }); ot._set("pie", ut.clone(ot.doughnut)), ot._set("pie", { cutoutPercentage: 0 }); const re = Xt; const oe = ut.valueOrDefault; const se = ut.options.resolve; ot._set("radar", { scale: { type: "radialLinear" }, elements: { line: { tension: 0 } } }); const le = kt.extend({
        datasetElementType: Nt.Line,
        dataElementType: Nt.Point,
        linkScales: ut.noop,
        update(t) { let e; let i; const n = this; const a = n.getMeta(); const r = a.dataset; const o = a.data || []; const s = n.chart.scale; const l = n.getDataset(); for (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), r._scale = s, r._datasetIndex = n.index, r._children = o, r._loop = !0, r._model = n._resolveLineOptions(r), r.pivot(), e = 0, i = o.length; e < i; ++e)n.updateElement(o[e], e, t); for (n.updateBezierControlPoints(), e = 0, i = o.length; e < i; ++e)o[e].pivot(); },
        updateElement(t, e, i) {
            const n = this; const a = t.custom || {}; const r = n.getDataset(); const o = n.chart.scale; const s = o.getPointPositionForValue(e, r.data[e]); const l = n._resolvePointOptions(t, e); const u = n.getMeta().dataset._model; const d = i ? o.xCenter : s.x; const h = i ? o.yCenter : s.y; t._scale = o, t._options = l, t._datasetIndex = n.index, t._index = e, t._model = {
                x: d, y: h, skip: a.skip || isNaN(d) || isNaN(h), radius: l.radius, pointStyle: l.pointStyle, rotation: l.rotation, backgroundColor: l.backgroundColor, borderColor: l.borderColor, borderWidth: l.borderWidth, tension: oe(a.tension, u ? u.tension : 0), hitRadius: l.hitRadius,
            };
        },
        _resolvePointOptions(t, e) {
            let i; let n; let a; const r = this.chart; const o = r.data.datasets[this.index]; const s = t.custom || {}; const l = r.options.elements.point; const u = {}; const d = {
                chart: r, dataIndex: e, dataset: o, datasetIndex: this.index,
            }; const h = {
                backgroundColor: "pointBackgroundColor", borderColor: "pointBorderColor", borderWidth: "pointBorderWidth", hitRadius: "pointHitRadius", hoverBackgroundColor: "pointHoverBackgroundColor", hoverBorderColor: "pointHoverBorderColor", hoverBorderWidth: "pointHoverBorderWidth", hoverRadius: "pointHoverRadius", pointStyle: "pointStyle", radius: "pointRadius", rotation: "pointRotation",
            }; const c = Object.keys(h); for (i = 0, n = c.length; i < n; ++i)u[a = c[i]] = se([s[a], o[h[a]], o[a], l[a]], d, e); return u;
        },
        _resolveLineOptions(t) { let e; let i; let n; const a = this.chart; const r = a.data.datasets[this.index]; const o = t.custom || {}; const s = a.options.elements.line; const l = {}; const u = ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"]; for (e = 0, i = u.length; e < i; ++e)l[n = u[e]] = se([o[n], r[n], s[n]]); return l.tension = oe(r.lineTension, s.tension), l; },
        updateBezierControlPoints() { let t; let e; let i; let n; const a = this.getMeta(); const r = this.chart.chartArea; const o = a.data || []; function s(t, e, i) { return Math.max(Math.min(t, i), e); } for (t = 0, e = o.length; t < e; ++t)i = o[t]._model, n = ut.splineCurve(ut.previousItem(o, t, !0)._model, i, ut.nextItem(o, t, !0)._model, i.tension), i.controlPointPreviousX = s(n.previous.x, r.left, r.right), i.controlPointPreviousY = s(n.previous.y, r.top, r.bottom), i.controlPointNextX = s(n.next.x, r.left, r.right), i.controlPointNextY = s(n.next.y, r.top, r.bottom); },
        setHoverStyle(t) {
            const e = t._model; const i = t._options; const n = ut.getHoverColor; t.$previousStyle = {
                backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth, radius: e.radius,
            }, e.backgroundColor = oe(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = oe(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = oe(i.hoverBorderWidth, i.borderWidth), e.radius = oe(i.hoverRadius, i.radius);
        },
    }); ot._set("scatter", {
        hover: { mode: "single" }, scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] }, showLines: !1, tooltips: { callbacks: { title() { return ""; }, label(t) { return `(${t.xLabel}, ${t.yLabel})`; } } },
    }); const ue = {
        bar: jt, bubble: qt, doughnut: Xt, horizontalBar: Kt, line: ie, polarArea: ae, pie: re, radar: le, scatter: ie,
    }; function de(t, e) { return t.native ? { x: t.x, y: t.y } : ut.getRelativePosition(t, e); } function he(t, e) { let i; let n; let a; let r; let o; for (n = 0, r = t.data.datasets.length; n < r; ++n) if (t.isDatasetVisible(n)) for (a = 0, o = (i = t.getDatasetMeta(n)).data.length; a < o; ++a) { const s = i.data[a]; s._view.skip || e(s); } } function ce(t, e) { const i = []; return he(t, (t) => { t.inRange(e.x, e.y) && i.push(t); }), i; } function fe(t, e, i, n) { let a = Number.POSITIVE_INFINITY; let r = []; return he(t, (t) => { if (!i || t.inRange(e.x, e.y)) { const o = t.getCenterPoint(); const s = n(e, o); s < a ? (r = [t], a = s) : s === a && r.push(t); } }), r; } function ge(t) { const e = t.indexOf("x") !== -1; const i = t.indexOf("y") !== -1; return function (t, n) { const a = e ? Math.abs(t.x - n.x) : 0; const r = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(a, 2) + Math.pow(r, 2)); }; } function me(t, e, i) { const n = de(e, t); i.axis = i.axis || "x"; const a = ge(i.axis); const r = i.intersect ? ce(t, n) : fe(t, n, !1, a); const o = []; return r.length ? (t.data.datasets.forEach((e, i) => { if (t.isDatasetVisible(i)) { const n = t.getDatasetMeta(i).data[r[0]._index]; n && !n._view.skip && o.push(n); } }), o) : []; } const pe = {
        modes: {
            single(t, e) { const i = de(e, t); const n = []; return he(t, (t) => { if (t.inRange(i.x, i.y)) return n.push(t), n; }), n.slice(0, 1); }, label: me, index: me, dataset(t, e, i) { const n = de(e, t); i.axis = i.axis || "xy"; const a = ge(i.axis); let r = i.intersect ? ce(t, n) : fe(t, n, !1, a); return r.length > 0 && (r = t.getDatasetMeta(r[0]._datasetIndex).data), r; }, "x-axis": function (t, e) { return me(t, e, { intersect: !1 }); }, point(t, e) { return ce(t, de(e, t)); }, nearest(t, e, i) { const n = de(e, t); i.axis = i.axis || "xy"; const a = ge(i.axis); return fe(t, n, i.intersect, a); }, x(t, e, i) { const n = de(e, t); let a = []; let r = !1; return he(t, (t) => { t.inXRange(n.x) && a.push(t), t.inRange(n.x, n.y) && (r = !0); }), i.intersect && !r && (a = []), a; }, y(t, e, i) { const n = de(e, t); let a = []; let r = !1; return he(t, (t) => { t.inYRange(n.y) && a.push(t), t.inRange(n.x, n.y) && (r = !0); }), i.intersect && !r && (a = []), a; },
        },
    }; function ve(t, e) { return ut.where(t, (t) => t.position === e); } function ye(t, e) { t.forEach((t, e) => (t._tmpIndex_ = e, t)), t.sort((t, i) => { const n = e ? i : t; const a = e ? t : i; return n.weight === a.weight ? n._tmpIndex_ - a._tmpIndex_ : n.weight - a.weight; }), t.forEach((t) => { delete t._tmpIndex_; }); } function be(t, e) { ut.each(t, (t) => { e[t.position] += t.isHorizontal() ? t.height : t.width; }); }ot._set("global", {
        layout: {
            padding: {
                top: 0, right: 0, bottom: 0, left: 0,
            },
        },
    }); const xe = {
        defaults: {},
        addBox(t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e); },
        removeBox(t, e) { const i = t.boxes ? t.boxes.indexOf(e) : -1; i !== -1 && t.boxes.splice(i, 1); },
        configure(t, e, i) { for (var n, a = ["fullWidth", "position", "weight"], r = a.length, o = 0; o < r; ++o)n = a[o], i.hasOwnProperty(n) && (e[n] = i[n]); },
        update(t, e, i) {
            if (t) {
                const n = t.options.layout || {}; const a = ut.options.toPadding(n.padding); var r = a.left; var o = a.right; const s = a.top; const l = a.bottom; const u = ve(t.boxes, "left"); const d = ve(t.boxes, "right"); const h = ve(t.boxes, "top"); const c = ve(t.boxes, "bottom"); const f = ve(t.boxes, "chartArea"); ye(u, !0), ye(d, !1), ye(h, !0), ye(c, !1); var g; const m = u.concat(d); const p = h.concat(c); const v = m.concat(p); var y = e - r - o; var b = i - s - l; const x = (e - y / 2) / m.length; var _ = y; var k = b; var w = {
                    top: s, left: r, bottom: l, right: o,
                }; var M = []; ut.each(v, (t) => { let e; const i = t.isHorizontal(); i ? (e = t.update(t.fullWidth ? y : _, b / 2), k -= e.height) : (e = t.update(x, k), _ -= e.width), M.push({ horizontal: i, width: e.width, box: t }); }), g = (function (t) {
                    let e = 0; let i = 0; let n = 0; let a = 0; return ut.each(t, (t) => { if (t.getPadding) { const r = t.getPadding(); e = Math.max(e, r.top), i = Math.max(i, r.left), n = Math.max(n, r.bottom), a = Math.max(a, r.right); } }), {
                        top: e, left: i, bottom: n, right: a,
                    };
                }(v)), ut.each(m, I), be(m, w), ut.each(p, I), be(p, w), ut.each(m, (t) => {
                    const e = ut.findNextWhere(M, (e) => e.box === t); const i = {
                        left: 0, right: 0, top: w.top, bottom: w.bottom,
                    }; e && t.update(e.width, k, i);
                }), be(v, w = {
                    top: s, left: r, bottom: l, right: o,
                }); const S = Math.max(g.left - w.left, 0); w.left += S, w.right += Math.max(g.right - w.right, 0); const D = Math.max(g.top - w.top, 0); w.top += D, w.bottom += Math.max(g.bottom - w.bottom, 0); const C = i - w.top - w.bottom; const P = e - w.left - w.right; P === _ && C === k || (ut.each(m, (t) => { t.height = C; }), ut.each(p, (t) => { t.fullWidth || (t.width = P); }), k = C, _ = P); var T = r + S; var O = s + D; ut.each(u.concat(h), A), T += _, O += k, ut.each(d, A), ut.each(c, A), t.chartArea = {
                    left: w.left, top: w.top, right: w.left + _, bottom: w.top + k,
                }, ut.each(f, (e) => { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(_, k); });
            } function I(t) {
                const e = ut.findNextWhere(M, (e) => e.box === t); if (e) {
                    if (e.horizontal) {
                        const i = {
                            left: Math.max(w.left, g.left), right: Math.max(w.right, g.right), top: 0, bottom: 0,
                        }; t.update(t.fullWidth ? y : _, b / 2, i);
                    } else t.update(e.width, k);
                }
            } function A(t) { t.isHorizontal() ? (t.left = t.fullWidth ? r : w.left, t.right = t.fullWidth ? e - o : w.left + _, t.top = O, t.bottom = O + t.height, O = t.bottom) : (t.left = T, t.right = T + t.width, t.top = w.top, t.bottom = w.top + k, T = t.right); }
        },
    }; typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" && self; function _e() { throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs"); } let ke; const we = (ke = Object.freeze({ default: "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}" })) && ke.default || ke; const Me = "$chartjs"; const Se = "chartjs-size-monitor"; const De = "chartjs-render-monitor"; const Ce = "chartjs-render-animation"; const Pe = ["animationstart", "webkitAnimationStart"]; const Te = {
        touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout",
    }; function Oe(t, e) { const i = ut.getStyle(t, e); const n = i && i.match(/^(\d+)(\.\d+)?px$/); return n ? Number(n[1]) : void 0; } const Ie = !!(function () { let t = !1; try { const e = Object.defineProperty({}, "passive", { get() { t = !0; } }); window.addEventListener("e", null, e); } catch (t) {} return t; }()) && { passive: !0 }; function Ae(t, e, i) { t.addEventListener(e, i, Ie); } function Fe(t, e, i) { t.removeEventListener(e, i, Ie); } function Re(t, e, i, n, a) {
        return {
            type: t, chart: e, native: a || null, x: void 0 !== i ? i : null, y: void 0 !== n ? n : null,
        };
    } function Le(t) { const e = document.createElement("div"); return e.className = t || "", e; } function We(t, e, i) { let n; let a; let r; let o; const s = t[Me] || (t[Me] = {}); const l = s.resizer = (function (t) { const e = Le(Se); const i = Le(`${Se}-expand`); const n = Le(`${Se}-shrink`); i.appendChild(Le()), n.appendChild(Le()), e.appendChild(i), e.appendChild(n), e._reset = function () { i.scrollLeft = 1e6, i.scrollTop = 1e6, n.scrollLeft = 1e6, n.scrollTop = 1e6; }; const a = function () { e._reset(), t(); }; return Ae(i, "scroll", a.bind(i, "expand")), Ae(n, "scroll", a.bind(n, "shrink")), e; }((n = function () { if (s.resizer) { const n = i.options.maintainAspectRatio && t.parentNode; const a = n ? n.clientWidth : 0; e(Re("resize", i)), n && n.clientWidth < a && i.canvas && e(Re("resize", i)); } }, r = !1, o = [], function () { o = Array.prototype.slice.call(arguments), a = a || this, r || (r = !0, ut.requestAnimFrame.call(window, () => { r = !1, n.apply(a, o); })); }))); !(function (t, e) { const i = t[Me] || (t[Me] = {}); const n = i.renderProxy = function (t) { t.animationName === Ce && e(); }; ut.each(Pe, (e) => { Ae(t, e, n); }), i.reflow = !!t.offsetParent, t.classList.add(De); }(t, () => { if (s.resizer) { const e = t.parentNode; e && e !== l.parentNode && e.insertBefore(l, e.firstChild), l._reset(); } })); } function Ye(t) { const e = t[Me] || {}; const i = e.resizer; delete e.resizer, (function (t) { const e = t[Me] || {}; const i = e.renderProxy; i && (ut.each(Pe, (e) => { Fe(t, e, i); }), delete e.renderProxy), t.classList.remove(De); }(t)), i && i.parentNode && i.parentNode.removeChild(i); } const Ne = {
        disableCSSInjection: !1, _enabled: typeof window !== "undefined" && typeof document !== "undefined", _ensureLoaded() { let t; let e; let i; this._loaded || (this._loaded = !0, this.disableCSSInjection || (e = we, i = (t = this)._style || document.createElement("style"), t._style || (t._style = i, e = `/* Chart.js */\n${e}`, i.setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(i)), i.appendChild(document.createTextNode(e)))); }, acquireContext(t, e) { typeof t === "string" ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas); const i = t && t.getContext && t.getContext("2d"); return this._ensureLoaded(), i && i.canvas === t ? ((function (t, e) { const i = t.style; const n = t.getAttribute("height"); const a = t.getAttribute("width"); if (t[Me] = { initial: { height: n, width: a, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || "block", a === null || a === "") { var r = Oe(t, "width"); void 0 !== r && (t.width = r); } if (n === null || n === "") if (t.style.height === "")t.height = t.width / (e.options.aspectRatio || 2); else { const o = Oe(t, "height"); void 0 !== r && (t.height = o); } }(t, e)), i) : null; }, releaseContext(t) { const e = t.canvas; if (e[Me]) { const i = e[Me].initial; ["height", "width"].forEach((t) => { const n = i[t]; ut.isNullOrUndef(n) ? e.removeAttribute(t) : e.setAttribute(t, n); }), ut.each(i.style || {}, (t, i) => { e.style[i] = t; }), e.width = e.width, delete e[Me]; } }, addEventListener(t, e, i) { const n = t.canvas; if (e !== "resize") { const a = i[Me] || (i[Me] = {}); Ae(n, e, (a.proxies || (a.proxies = {}))[`${t.id}_${e}`] = function (e) { i(function (t, e) { const i = Te[t.type] || t.type; const n = ut.getRelativePosition(t, e); return Re(i, e, n.x, n.y, t); }(e, t)); }); } else We(n, i, t); }, removeEventListener(t, e, i) { const n = t.canvas; if (e !== "resize") { const a = ((i[Me] || {}).proxies || {})[`${t.id}_${e}`]; a && Fe(n, e, a); } else Ye(n); },
    }; ut.addEvent = Ae, ut.removeEvent = Fe; const ze = Ne._enabled ? Ne : { acquireContext(t) { return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null; } }; const Ve = ut.extend({
        initialize() {}, acquireContext() {}, releaseContext() {}, addEventListener() {}, removeEventListener() {},
    }, ze); ot._set("global", { plugins: {} }); const He = {
        _plugins: [], _cacheId: 0, register(t) { const e = this._plugins; [].concat(t).forEach((t) => { e.indexOf(t) === -1 && e.push(t); }), this._cacheId++; }, unregister(t) { const e = this._plugins; [].concat(t).forEach((t) => { const i = e.indexOf(t); i !== -1 && e.splice(i, 1); }), this._cacheId++; }, clear() { this._plugins = [], this._cacheId++; }, count() { return this._plugins.length; }, getAll() { return this._plugins; }, notify(t, e, i) { let n; let a; let r; let o; let s; const l = this.descriptors(t); const u = l.length; for (n = 0; n < u; ++n) if (typeof (s = (r = (a = l[n]).plugin)[e]) === "function" && ((o = [t].concat(i || [])).push(a.options), !1 === s.apply(r, o))) return !1; return !0; }, descriptors(t) { const e = t.$plugins || (t.$plugins = {}); if (e.id === this._cacheId) return e.descriptors; const i = []; const n = []; const a = t && t.config || {}; const r = a.options && a.options.plugins || {}; return this._plugins.concat(a.plugins || []).forEach((t) => { if (i.indexOf(t) === -1) { const e = t.id; let a = r[e]; !1 !== a && (!0 === a && (a = ut.clone(ot.global.plugins[e])), i.push(t), n.push({ plugin: t, options: a || {} })); } }), e.descriptors = n, e.id = this._cacheId, n; }, _invalidate(t) { delete t.$plugins; },
    }; const Ee = {
        constructors: {}, defaults: {}, registerScaleType(t, e, i) { this.constructors[t] = e, this.defaults[t] = ut.clone(i); }, getScaleConstructor(t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0; }, getScaleDefaults(t) { return this.defaults.hasOwnProperty(t) ? ut.merge({}, [ot.scale, this.defaults[t]]) : {}; }, updateScaleDefaults(t, e) { this.defaults.hasOwnProperty(t) && (this.defaults[t] = ut.extend(this.defaults[t], e)); }, addScalesToLayout(t) { ut.each(t.scales, (e) => { e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, xe.addBox(t, e); }); },
    }; const Be = ut.valueOrDefault; ot._set("global", {
        tooltips: {
            enabled: !0,
            custom: null,
            mode: "nearest",
            position: "average",
            intersect: !0,
            backgroundColor: "rgba(0,0,0,0.8)",
            titleFontStyle: "bold",
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleFontColor: "#fff",
            titleAlign: "left",
            bodySpacing: 2,
            bodyFontColor: "#fff",
            bodyAlign: "left",
            footerFontStyle: "bold",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFontColor: "#fff",
            footerAlign: "left",
            yPadding: 6,
            xPadding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            multiKeyBackground: "#fff",
            displayColors: !0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            callbacks: {
                beforeTitle: ut.noop, title(t, e) { let i = ""; const n = e.labels; const a = n ? n.length : 0; if (t.length > 0) { const r = t[0]; r.label ? i = r.label : r.xLabel ? i = r.xLabel : a > 0 && r.index < a && (i = n[r.index]); } return i; }, afterTitle: ut.noop, beforeBody: ut.noop, beforeLabel: ut.noop, label(t, e) { let i = e.datasets[t.datasetIndex].label || ""; return i && (i += ": "), ut.isNullOrUndef(t.value) ? i += t.yLabel : i += t.value, i; }, labelColor(t, e) { const i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: i.borderColor, backgroundColor: i.backgroundColor }; }, labelTextColor() { return this._options.bodyFontColor; }, afterLabel: ut.noop, afterBody: ut.noop, beforeFooter: ut.noop, footer: ut.noop, afterFooter: ut.noop,
            },
        },
    }); const je = { average(t) { if (!t.length) return !1; let e; let i; let n = 0; let a = 0; let r = 0; for (e = 0, i = t.length; e < i; ++e) { const o = t[e]; if (o && o.hasValue()) { const s = o.tooltipPosition(); n += s.x, a += s.y, ++r; } } return { x: n / r, y: a / r }; }, nearest(t, e) { let i; let n; let a; let r = e.x; let o = e.y; let s = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { const l = t[i]; if (l && l.hasValue()) { const u = l.getCenterPoint(); const d = ut.distanceBetweenPoints(e, u); d < s && (s = d, a = l); } } if (a) { const h = a.tooltipPosition(); r = h.x, o = h.y; } return { x: r, y: o }; } }; function Ue(t, e) { return e && (ut.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t; } function Ge(t) { return (typeof t === "string" || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t; } function qe(t) {
        const e = ot.global; return {
            xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, bodyFontColor: t.bodyFontColor, _bodyFontFamily: Be(t.bodyFontFamily, e.defaultFontFamily), _bodyFontStyle: Be(t.bodyFontStyle, e.defaultFontStyle), _bodyAlign: t.bodyAlign, bodyFontSize: Be(t.bodyFontSize, e.defaultFontSize), bodySpacing: t.bodySpacing, titleFontColor: t.titleFontColor, _titleFontFamily: Be(t.titleFontFamily, e.defaultFontFamily), _titleFontStyle: Be(t.titleFontStyle, e.defaultFontStyle), titleFontSize: Be(t.titleFontSize, e.defaultFontSize), _titleAlign: t.titleAlign, titleSpacing: t.titleSpacing, titleMarginBottom: t.titleMarginBottom, footerFontColor: t.footerFontColor, _footerFontFamily: Be(t.footerFontFamily, e.defaultFontFamily), _footerFontStyle: Be(t.footerFontStyle, e.defaultFontStyle), footerFontSize: Be(t.footerFontSize, e.defaultFontSize), _footerAlign: t.footerAlign, footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, cornerRadius: t.cornerRadius, backgroundColor: t.backgroundColor, opacity: 0, legendColorBackground: t.multiKeyBackground, displayColors: t.displayColors, borderColor: t.borderColor, borderWidth: t.borderWidth,
        };
    } function Ze(t, e) { return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - t.xPadding : t.x + t.xPadding; } function $e(t) { return Ue([], Ge(t)); } const Xe = gt.extend({
        initialize() { this._model = qe(this._options), this._lastActive = []; },
        getTitle() { const t = this._options.callbacks; const e = t.beforeTitle.apply(this, arguments); const i = t.title.apply(this, arguments); const n = t.afterTitle.apply(this, arguments); let a = []; return a = Ue(a, Ge(e)), a = Ue(a, Ge(i)), a = Ue(a, Ge(n)); },
        getBeforeBody() { return $e(this._options.callbacks.beforeBody.apply(this, arguments)); },
        getBody(t, e) { const i = this; const n = i._options.callbacks; const a = []; return ut.each(t, (t) => { const r = { before: [], lines: [], after: [] }; Ue(r.before, Ge(n.beforeLabel.call(i, t, e))), Ue(r.lines, n.label.call(i, t, e)), Ue(r.after, Ge(n.afterLabel.call(i, t, e))), a.push(r); }), a; },
        getAfterBody() { return $e(this._options.callbacks.afterBody.apply(this, arguments)); },
        getFooter() { const t = this._options.callbacks; const e = t.beforeFooter.apply(this, arguments); const i = t.footer.apply(this, arguments); const n = t.afterFooter.apply(this, arguments); let a = []; return a = Ue(a, Ge(e)), a = Ue(a, Ge(i)), a = Ue(a, Ge(n)); },
        update(t) {
            let e; let i; let n; let a; let r; let o; let s; let l; let u; let d; const h = this; const c = h._options; const f = h._model; const g = h._model = qe(c); const m = h._active; const p = h._data; let v = { xAlign: f.xAlign, yAlign: f.yAlign }; let y = { x: f.x, y: f.y }; let b = { width: f.width, height: f.height }; let x = { x: f.caretX, y: f.caretY }; if (m.length) {
                g.opacity = 1; const _ = []; const k = []; x = je[c.position].call(h, m, h._eventPosition); let w = []; for (e = 0, i = m.length; e < i; ++e) {
                    w.push((n = m[e], a = void 0, r = void 0, o = void 0, s = void 0, l = void 0, u = void 0, d = void 0, a = n._xScale, r = n._yScale || n._scale, o = n._index, s = n._datasetIndex, l = n._chart.getDatasetMeta(s).controller, u = l._getIndexScale(), d = l._getValueScale(), {
                        xLabel: a ? a.getLabelForIndex(o, s) : "", yLabel: r ? r.getLabelForIndex(o, s) : "", label: u ? `${u.getLabelForIndex(o, s)}` : "", value: d ? `${d.getLabelForIndex(o, s)}` : "", index: o, datasetIndex: s, x: n._model.x, y: n._model.y,
                    }));
                } c.filter && (w = w.filter((t) => c.filter(t, p))), c.itemSort && (w = w.sort((t, e) => c.itemSort(t, e, p))), ut.each(w, (t) => { _.push(c.callbacks.labelColor.call(h, t, h._chart)), k.push(c.callbacks.labelTextColor.call(h, t, h._chart)); }), g.title = h.getTitle(w, p), g.beforeBody = h.getBeforeBody(w, p), g.body = h.getBody(w, p), g.afterBody = h.getAfterBody(w, p), g.footer = h.getFooter(w, p), g.x = x.x, g.y = x.y, g.caretPadding = c.caretPadding, g.labelColors = _, g.labelTextColors = k, g.dataPoints = w, b = (function (t, e) { const i = t._chart.ctx; let n = 2 * e.yPadding; let a = 0; const r = e.body; let o = r.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0); o += e.beforeBody.length + e.afterBody.length; const s = e.title.length; const l = e.footer.length; const u = e.titleFontSize; const d = e.bodyFontSize; const h = e.footerFontSize; n += s * u, n += s ? (s - 1) * e.titleSpacing : 0, n += s ? e.titleMarginBottom : 0, n += o * d, n += o ? (o - 1) * e.bodySpacing : 0, n += l ? e.footerMarginTop : 0, n += l * h, n += l ? (l - 1) * e.footerSpacing : 0; let c = 0; const f = function (t) { a = Math.max(a, i.measureText(t).width + c); }; return i.font = ut.fontString(u, e._titleFontStyle, e._titleFontFamily), ut.each(e.title, f), i.font = ut.fontString(d, e._bodyFontStyle, e._bodyFontFamily), ut.each(e.beforeBody.concat(e.afterBody), f), c = e.displayColors ? d + 2 : 0, ut.each(r, (t) => { ut.each(t.before, f), ut.each(t.lines, f), ut.each(t.after, f); }), c = 0, i.font = ut.fontString(h, e._footerFontStyle, e._footerFontFamily), ut.each(e.footer, f), { width: a += 2 * e.xPadding, height: n }; }(this, g)), y = (function (t, e, i, n) { let a = t.x; let r = t.y; const o = t.caretSize; const s = t.caretPadding; const l = t.cornerRadius; const u = i.xAlign; const d = i.yAlign; const h = o + s; const c = l + s; return u === "right" ? a -= e.width : u === "center" && ((a -= e.width / 2) + e.width > n.width && (a = n.width - e.width), a < 0 && (a = 0)), d === "top" ? r += h : r -= d === "bottom" ? e.height + h : e.height / 2, d === "center" ? u === "left" ? a += h : u === "right" && (a -= h) : u === "left" ? a -= c : u === "right" && (a += c), { x: a, y: r }; }(g, b, v = (function (t, e) { let i; let n; let a; let r; let o; const s = t._model; const l = t._chart; const u = t._chart.chartArea; let d = "center"; let h = "center"; s.y < e.height ? h = "top" : s.y > l.height - e.height && (h = "bottom"); const c = (u.left + u.right) / 2; const f = (u.top + u.bottom) / 2; h === "center" ? (i = function (t) { return t <= c; }, n = function (t) { return t > c; }) : (i = function (t) { return t <= e.width / 2; }, n = function (t) { return t >= l.width - e.width / 2; }), a = function (t) { return t + e.width + s.caretSize + s.caretPadding > l.width; }, r = function (t) { return t - e.width - s.caretSize - s.caretPadding < 0; }, o = function (t) { return t <= f ? "top" : "bottom"; }, i(s.x) ? (d = "left", a(s.x) && (d = "center", h = o(s.y))) : n(s.x) && (d = "right", r(s.x) && (d = "center", h = o(s.y))); const g = t._options; return { xAlign: g.xAlign ? g.xAlign : d, yAlign: g.yAlign ? g.yAlign : h }; }(this, b)), h._chart));
            } else g.opacity = 0; return g.xAlign = v.xAlign, g.yAlign = v.yAlign, g.x = y.x, g.y = y.y, g.width = b.width, g.height = b.height, g.caretX = x.x, g.caretY = x.y, h._model = g, t && c.custom && c.custom.call(h, g), h;
        },
        drawCaret(t, e) { const i = this._chart.ctx; const n = this._view; const a = this.getCaretPosition(t, e, n); i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3); },
        getCaretPosition(t, e, i) {
            let n; let a; let r; let o; let s; let l; const u = i.caretSize; const d = i.cornerRadius; const h = i.xAlign; const c = i.yAlign; const f = t.x; const g = t.y; const m = e.width; const p = e.height; if (c === "center")s = g + p / 2, h === "left" ? (a = (n = f) - u, r = n, o = s + u, l = s - u) : (a = (n = f + m) + u, r = n, o = s - u, l = s + u); else if (h === "left" ? (n = (a = f + d + u) - u, r = a + u) : h === "right" ? (n = (a = f + m - d - u) - u, r = a + u) : (n = (a = i.caretX) - u, r = a + u), c === "top")s = (o = g) - u, l = o; else { s = (o = g + p) + u, l = o; const v = r; r = n, n = v; } return {
                x1: n, x2: a, x3: r, y1: o, y2: s, y3: l,
            };
        },
        drawTitle(t, e, i) { const n = e.title; if (n.length) { t.x = Ze(e, e._titleAlign), i.textAlign = e._titleAlign, i.textBaseline = "top"; let a; let r; const o = e.titleFontSize; const s = e.titleSpacing; for (i.fillStyle = e.titleFontColor, i.font = ut.fontString(o, e._titleFontStyle, e._titleFontFamily), a = 0, r = n.length; a < r; ++a)i.fillText(n[a], t.x, t.y), t.y += o + s, a + 1 === n.length && (t.y += e.titleMarginBottom - s); } },
        drawBody(t, e, i) { let n; const a = e.bodyFontSize; const r = e.bodySpacing; const o = e._bodyAlign; const s = e.body; const l = e.displayColors; const u = e.labelColors; let d = 0; const h = l ? Ze(e, "left") : 0; i.textAlign = o, i.textBaseline = "top", i.font = ut.fontString(a, e._bodyFontStyle, e._bodyFontFamily), t.x = Ze(e, o); const c = function (e) { i.fillText(e, t.x + d, t.y), t.y += a + r; }; i.fillStyle = e.bodyFontColor, ut.each(e.beforeBody, c), d = l && o !== "right" ? o === "center" ? a / 2 + 1 : a + 2 : 0, ut.each(s, (r, o) => { n = e.labelTextColors[o], i.fillStyle = n, ut.each(r.before, c), ut.each(r.lines, (r) => { l && (i.fillStyle = e.legendColorBackground, i.fillRect(h, t.y, a, a), i.lineWidth = 1, i.strokeStyle = u[o].borderColor, i.strokeRect(h, t.y, a, a), i.fillStyle = u[o].backgroundColor, i.fillRect(h + 1, t.y + 1, a - 2, a - 2), i.fillStyle = n), c(r); }), ut.each(r.after, c); }), d = 0, ut.each(e.afterBody, c), t.y -= r; },
        drawFooter(t, e, i) { const n = e.footer; n.length && (t.x = Ze(e, e._footerAlign), t.y += e.footerMarginTop, i.textAlign = e._footerAlign, i.textBaseline = "top", i.fillStyle = e.footerFontColor, i.font = ut.fontString(e.footerFontSize, e._footerFontStyle, e._footerFontFamily), ut.each(n, (n) => { i.fillText(n, t.x, t.y), t.y += e.footerFontSize + e.footerSpacing; })); },
        drawBackground(t, e, i, n) { i.fillStyle = e.backgroundColor, i.strokeStyle = e.borderColor, i.lineWidth = e.borderWidth; const a = e.xAlign; const r = e.yAlign; const o = t.x; const s = t.y; const l = n.width; const u = n.height; const d = e.cornerRadius; i.beginPath(), i.moveTo(o + d, s), r === "top" && this.drawCaret(t, n), i.lineTo(o + l - d, s), i.quadraticCurveTo(o + l, s, o + l, s + d), r === "center" && a === "right" && this.drawCaret(t, n), i.lineTo(o + l, s + u - d), i.quadraticCurveTo(o + l, s + u, o + l - d, s + u), r === "bottom" && this.drawCaret(t, n), i.lineTo(o + d, s + u), i.quadraticCurveTo(o, s + u, o, s + u - d), r === "center" && a === "left" && this.drawCaret(t, n), i.lineTo(o, s + d), i.quadraticCurveTo(o, s, o + d, s), i.closePath(), i.fill(), e.borderWidth > 0 && i.stroke(); },
        draw() { const t = this._chart.ctx; const e = this._view; if (e.opacity !== 0) { const i = { width: e.width, height: e.height }; const n = { x: e.x, y: e.y }; const a = Math.abs(e.opacity < 0.001) ? 0 : e.opacity; const r = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; this._options.enabled && r && (t.save(), t.globalAlpha = a, this.drawBackground(n, e, t, i), n.y += e.yPadding, this.drawTitle(n, e, t), this.drawBody(n, e, t), this.drawFooter(n, e, t), t.restore()); } },
        handleEvent(t) { let e; const i = this; const n = i._options; return i._lastActive = i._lastActive || [], t.type === "mouseout" ? i._active = [] : i._active = i._chart.getElementsAtEventForMode(t, n.mode, n), (e = !ut.arrayEquals(i._active, i._lastActive)) && (i._lastActive = i._active, (n.enabled || n.custom) && (i._eventPosition = { x: t.x, y: t.y }, i.update(!0), i.pivot())), e; },
    }); const Ke = je; const Je = Xe; Je.positioners = Ke; const Qe = ut.valueOrDefault; function ti() { return ut.merge({}, [].slice.call(arguments), { merger(t, e, i, n) { if (t === "xAxes" || t === "yAxes") { let a; let r; let o; const s = i[t].length; for (e[t] || (e[t] = []), a = 0; a < s; ++a)o = i[t][a], r = Qe(o.type, t === "xAxes" ? "category" : "linear"), a >= e[t].length && e[t].push({}), !e[t][a].type || o.type && o.type !== e[t][a].type ? ut.merge(e[t][a], [Ee.getScaleDefaults(r), o]) : ut.merge(e[t][a], o); } else ut._merger(t, e, i, n); } }); } function ei() { return ut.merge({}, [].slice.call(arguments), { merger(t, e, i, n) { const a = e[t] || {}; const r = i[t]; t === "scales" ? e[t] = ti(a, r) : t === "scale" ? e[t] = ut.merge(a, [Ee.getScaleDefaults(r.type), r]) : ut._merger(t, e, i, n); } }); } function ii(t) { return t === "top" || t === "bottom"; }ot._set("global", {
        elements: {},
        events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
        hover: {
            onHover: null, mode: "nearest", intersect: !0, animationDuration: 400,
        },
        onClick: null,
        maintainAspectRatio: !0,
        responsive: !0,
        responsiveAnimationDuration: 0,
    }); const ni = function (t, e) { return this.construct(t, e), this; }; ut.extend(ni.prototype, {
        construct(t, e) { const i = this; e = (function (t) { const e = (t = t || {}).data = t.data || {}; return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = ei(ot.global, ot[t.type], t.options || {}), t; }(e)); const n = Ve.acquireContext(t, e); const a = n && n.canvas; const r = a && a.height; const o = a && a.width; i.id = ut.uid(), i.ctx = n, i.canvas = a, i.config = e, i.width = o, i.height = r, i.aspectRatio = r ? o / r : null, i.options = e.options, i._bufferedRender = !1, i.chart = i, i.controller = i, ni.instances[i.id] = i, Object.defineProperty(i, "data", { get() { return i.config.data; }, set(t) { i.config.data = t; } }), n && a ? (i.initialize(), i.update()) : console.error("Failed to create chart: can't acquire context from the given item"); },
        initialize() { const t = this; return He.notify(t, "beforeInit"), ut.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.initToolTip(), He.notify(t, "afterInit"), t; },
        clear() { return ut.canvas.clear(this), this; },
        stop() { return vt.cancelAnimation(this), this; },
        resize(t) { const e = this; const i = e.options; const n = e.canvas; const a = i.maintainAspectRatio && e.aspectRatio || null; const r = Math.max(0, Math.floor(ut.getMaximumWidth(n))); const o = Math.max(0, Math.floor(a ? r / a : ut.getMaximumHeight(n))); if ((e.width !== r || e.height !== o) && (n.width = e.width = r, n.height = e.height = o, n.style.width = `${r}px`, n.style.height = `${o}px`, ut.retinaScale(e, i.devicePixelRatio), !t)) { const s = { width: r, height: o }; He.notify(e, "resize", [s]), i.onResize && i.onResize(e, s), e.stop(), e.update({ duration: i.responsiveAnimationDuration }); } },
        ensureScalesHaveIDs() { const t = this.options; const e = t.scales || {}; const i = t.scale; ut.each(e.xAxes, (t, e) => { t.id = t.id || `x-axis-${e}`; }), ut.each(e.yAxes, (t, e) => { t.id = t.id || `y-axis-${e}`; }), i && (i.id = i.id || "scale"); },
        buildOrUpdateScales() {
            const t = this; const e = t.options; const i = t.scales || {}; let n = []; const a = Object.keys(i).reduce((t, e) => (t[e] = !1, t), {}); e.scales && (n = n.concat((e.scales.xAxes || []).map((t) => ({ options: t, dtype: "category", dposition: "bottom" })), (e.scales.yAxes || []).map((t) => ({ options: t, dtype: "linear", dposition: "left" })))), e.scale && n.push({
                options: e.scale, dtype: "radialLinear", isDefault: !0, dposition: "chartArea",
            }), ut.each(n, (e) => {
                const n = e.options; const r = n.id; const o = Qe(n.type, e.dtype); ii(n.position) !== ii(e.dposition) && (n.position = e.dposition), a[r] = !0; let s = null; if (r in i && i[r].type === o)(s = i[r]).options = n, s.ctx = t.ctx, s.chart = t; else {
                    const l = Ee.getScaleConstructor(o); if (!l) return; s = new l({
                        id: r, type: o, options: n, ctx: t.ctx, chart: t,
                    }), i[s.id] = s;
                }s.mergeTicksOptions(), e.isDefault && (t.scale = s);
            }), ut.each(a, (t, e) => { t || delete i[e]; }), t.scales = i, Ee.addScalesToLayout(this);
        },
        buildOrUpdateControllers() { const t = this; const e = []; return ut.each(t.data.datasets, (i, n) => { let a = t.getDatasetMeta(n); const r = i.type || t.config.type; if (a.type && a.type !== r && (t.destroyDatasetMeta(n), a = t.getDatasetMeta(n)), a.type = r, a.controller)a.controller.updateIndex(n), a.controller.linkScales(); else { const o = ue[a.type]; if (void 0 === o) throw new Error(`"${a.type}" is not a chart type.`); a.controller = new o(t, n), e.push(a.controller); } }, t), e; },
        resetElements() { const t = this; ut.each(t.data.datasets, (e, i) => { t.getDatasetMeta(i).controller.reset(); }, t); },
        reset() { this.resetElements(), this.tooltip.initialize(); },
        update(t) { let e; let i; const n = this; if (t && typeof t === "object" || (t = { duration: t, lazy: arguments[1] }), i = (e = n).options, ut.each(e.scales, (t) => { xe.removeBox(e, t); }), i = ei(ot.global, ot[e.config.type], i), e.options = e.config.options = i, e.ensureScalesHaveIDs(), e.buildOrUpdateScales(), e.tooltip._options = i.tooltips, e.tooltip.initialize(), He._invalidate(n), !1 !== He.notify(n, "beforeUpdate")) { n.tooltip._data = n.data; const a = n.buildOrUpdateControllers(); ut.each(n.data.datasets, (t, e) => { n.getDatasetMeta(e).controller.buildOrUpdateElements(); }, n), n.updateLayout(), n.options.animation && n.options.animation.duration && ut.each(a, (t) => { t.reset(); }), n.updateDatasets(), n.tooltip.initialize(), n.lastActive = [], He.notify(n, "afterUpdate"), n._bufferedRender ? n._bufferedRequest = { duration: t.duration, easing: t.easing, lazy: t.lazy } : n.render(t); } },
        updateLayout() { !1 !== He.notify(this, "beforeLayout") && (xe.update(this, this.width, this.height), He.notify(this, "afterScaleUpdate"), He.notify(this, "afterLayout")); },
        updateDatasets() { if (!1 !== He.notify(this, "beforeDatasetsUpdate")) { for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.updateDataset(t); He.notify(this, "afterDatasetsUpdate"); } },
        updateDataset(t) { const e = this.getDatasetMeta(t); const i = { meta: e, index: t }; !1 !== He.notify(this, "beforeDatasetUpdate", [i]) && (e.controller.update(), He.notify(this, "afterDatasetUpdate", [i])); },
        render(t) {
            const e = this; t && typeof t === "object" || (t = { duration: t, lazy: arguments[1] }); const i = e.options.animation; const n = Qe(t.duration, i && i.duration); const a = t.lazy; if (!1 !== He.notify(e, "beforeRender")) {
                const r = function (t) { He.notify(e, "afterRender"), ut.callback(i && i.onComplete, [t], e); }; if (i && n) {
                    const o = new pt({
                        numSteps: n / 16.66, easing: t.easing || i.easing, render(t, e) { const i = ut.easing.effects[e.easing]; const n = e.currentStep; const a = n / e.numSteps; t.draw(i(a), a, n); }, onAnimationProgress: i.onProgress, onAnimationComplete: r,
                    }); vt.addAnimation(e, o, n, a);
                } else e.draw(), r(new pt({ numSteps: 0, chart: e })); return e;
            }
        },
        draw(t) { const e = this; e.clear(), ut.isNullOrUndef(t) && (t = 1), e.transition(t), e.width <= 0 || e.height <= 0 || !1 !== He.notify(e, "beforeDraw", [t]) && (ut.each(e.boxes, (t) => { t.draw(e.chartArea); }, e), e.drawDatasets(t), e._drawTooltip(t), He.notify(e, "afterDraw", [t])); },
        transition(t) { for (let e = 0, i = (this.data.datasets || []).length; e < i; ++e) this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t); this.tooltip.transition(t); },
        drawDatasets(t) { const e = this; if (!1 !== He.notify(e, "beforeDatasetsDraw", [t])) { for (let i = (e.data.datasets || []).length - 1; i >= 0; --i)e.isDatasetVisible(i) && e.drawDataset(i, t); He.notify(e, "afterDatasetsDraw", [t]); } },
        drawDataset(t, e) { const i = this.getDatasetMeta(t); const n = { meta: i, index: t, easingValue: e }; !1 !== He.notify(this, "beforeDatasetDraw", [n]) && (i.controller.draw(e), He.notify(this, "afterDatasetDraw", [n])); },
        _drawTooltip(t) { const e = this.tooltip; const i = { tooltip: e, easingValue: t }; !1 !== He.notify(this, "beforeTooltipDraw", [i]) && (e.draw(), He.notify(this, "afterTooltipDraw", [i])); },
        getElementAtEvent(t) { return pe.modes.single(this, t); },
        getElementsAtEvent(t) { return pe.modes.label(this, t, { intersect: !0 }); },
        getElementsAtXAxis(t) { return pe.modes["x-axis"](this, t, { intersect: !0 }); },
        getElementsAtEventForMode(t, e, i) { const n = pe.modes[e]; return typeof n === "function" ? n(this, t, i) : []; },
        getDatasetAtEvent(t) { return pe.modes.dataset(this, t, { intersect: !0 }); },
        getDatasetMeta(t) {
            const e = this.data.datasets[t]; e._meta || (e._meta = {}); let i = e._meta[this.id]; return i || (i = e._meta[this.id] = {
                type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null,
            }), i;
        },
        getVisibleDatasetCount() { for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e) this.isDatasetVisible(e) && t++; return t; },
        isDatasetVisible(t) { const e = this.getDatasetMeta(t); return typeof e.hidden === "boolean" ? !e.hidden : !this.data.datasets[t].hidden; },
        generateLegend() { return this.options.legendCallback(this); },
        destroyDatasetMeta(t) { const e = this.id; const i = this.data.datasets[t]; const n = i._meta && i._meta[e]; n && (n.controller.destroy(), delete i._meta[e]); },
        destroy() { let t; let e; const i = this; const n = i.canvas; for (i.stop(), t = 0, e = i.data.datasets.length; t < e; ++t)i.destroyDatasetMeta(t); n && (i.unbindEvents(), ut.canvas.clear(i), Ve.releaseContext(i.ctx), i.canvas = null, i.ctx = null), He.notify(i, "destroy"), delete ni.instances[i.id]; },
        toBase64Image() { return this.canvas.toDataURL.apply(this.canvas, arguments); },
        initToolTip() {
            const t = this; t.tooltip = new Je({
                _chart: t, _chartInstance: t, _data: t.data, _options: t.options.tooltips,
            }, t);
        },
        bindEvents() { const t = this; const e = t._listeners = {}; let i = function () { t.eventHandler.apply(t, arguments); }; ut.each(t.options.events, (n) => { Ve.addEventListener(t, n, i), e[n] = i; }), t.options.responsive && (i = function () { t.resize(); }, Ve.addEventListener(t, "resize", i), e.resize = i); },
        unbindEvents() { const t = this; const e = t._listeners; e && (delete t._listeners, ut.each(e, (e, i) => { Ve.removeEventListener(t, i, e); })); },
        updateHoverStyle(t, e, i) { let n; let a; let r; const o = i ? "setHoverStyle" : "removeHoverStyle"; for (a = 0, r = t.length; a < r; ++a)(n = t[a]) && this.getDatasetMeta(n._datasetIndex).controller[o](n); },
        eventHandler(t) { const e = this; const i = e.tooltip; if (!1 !== He.notify(e, "beforeEvent", [t])) { e._bufferedRender = !0, e._bufferedRequest = null; let n = e.handleEvent(t); i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), He.notify(e, "afterEvent", [t]); const a = e._bufferedRequest; return a ? e.render(a) : n && !e.animating && (e.stop(), e.render({ duration: e.options.hover.animationDuration, lazy: !0 })), e._bufferedRender = !1, e._bufferedRequest = null, e; } },
        handleEvent(t) { let e; const i = this; const n = i.options || {}; const a = n.hover; return i.lastActive = i.lastActive || [], t.type === "mouseout" ? i.active = [] : i.active = i.getElementsAtEventForMode(t, a.mode, a), ut.callback(n.onHover || n.hover.onHover, [t.native, i.active], i), t.type !== "mouseup" && t.type !== "click" || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, a.mode, !1), i.active.length && a.mode && i.updateHoverStyle(i.active, a.mode, !0), e = !ut.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, e; },
    }), ni.instances = {}; const ai = ni; ni.Controller = ni, ni.types = {}, ut.configMerge = ei, ut.scaleMerge = ti; function ri() { throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided."); } function oi(t) { this.options = t || {}; }ut.extend(oi.prototype, {
        formats: ri, parse: ri, format: ri, add: ri, diff: ri, startOf: ri, endOf: ri, _create(t) { return t; },
    }), oi.override = function (t) { ut.extend(oi.prototype, t); }; const si = { _date: oi }; const li = { formatters: { values(t) { return ut.isArray(t) ? t : `${t}`; }, linear(t, e, i) { let n = i.length > 3 ? i[2] - i[1] : i[1] - i[0]; Math.abs(n) > 1 && t !== Math.floor(t) && (n = t - Math.floor(t)); const a = ut.log10(Math.abs(n)); let r = ""; if (t !== 0) if (Math.max(Math.abs(i[0]), Math.abs(i[i.length - 1])) < 1e-4) { const o = ut.log10(Math.abs(t)); r = t.toExponential(Math.floor(o) - Math.floor(a)); } else { let s = -1 * Math.floor(a); s = Math.max(Math.min(s, 20), 0), r = t.toFixed(s); } else r = "0"; return r; }, logarithmic(t, e, i) { const n = t / Math.pow(10, Math.floor(ut.log10(t))); return t === 0 ? "0" : n === 1 || n === 2 || n === 5 || e === 0 || e === i.length - 1 ? t.toExponential() : ""; } } }; const ui = ut.valueOrDefault; const di = ut.valueAtIndexOrDefault; function hi(t) { let e; let i; const n = []; for (e = 0, i = t.length; e < i; ++e)n.push(t[e].label); return n; } function ci(t, e, i) { return ut.isArray(e) ? ut.longestText(t, i, e) : t.measureText(e).width; }ot._set("scale", {
        display: !0,
        position: "left",
        offset: !1,
        gridLines: {
            display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: !1, borderDash: [], borderDashOffset: 0,
        },
        scaleLabel: { display: !1, labelString: "", padding: { top: 4, bottom: 4 } },
        ticks: {
            beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: li.formatters.values, minor: {}, major: {},
        },
    }); const fi = gt.extend({
        getPadding() {
            return {
                left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0,
            };
        },
        getTicks() { return this._ticks; },
        mergeTicksOptions() { const t = this.options.ticks; for (const e in !1 === t.minor && (t.minor = { display: !1 }), !1 === t.major && (t.major = { display: !1 }), t)e !== "major" && e !== "minor" && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e])); },
        beforeUpdate() { ut.callback(this.options.beforeUpdate, [this]); },
        update(t, e, i) {
            let n; let a; let r; let o; let s; let l; const u = this; for (u.beforeUpdate(), u.maxWidth = t, u.maxHeight = e, u.margins = ut.extend({
                left: 0, right: 0, top: 0, bottom: 0,
            }, i), u._maxLabelLines = 0, u.longestLabelWidth = 0, u.longestTextCache = u.longestTextCache || {}, u.beforeSetDimensions(), u.setDimensions(), u.afterSetDimensions(), u.beforeDataLimits(), u.determineDataLimits(), u.afterDataLimits(), u.beforeBuildTicks(), s = u.buildTicks() || [], s = u.afterBuildTicks(s) || s, u.beforeTickToLabelConversion(), r = u.convertTicksToLabels(s) || u.ticks, u.afterTickToLabelConversion(), u.ticks = r, n = 0, a = r.length; n < a; ++n)o = r[n], (l = s[n]) ? l.label = o : s.push(l = { label: o, major: !1 }); return u._ticks = s, u.beforeCalculateTickRotation(), u.calculateTickRotation(), u.afterCalculateTickRotation(), u.beforeFit(), u.fit(), u.afterFit(), u.afterUpdate(), u.minSize;
        },
        afterUpdate() { ut.callback(this.options.afterUpdate, [this]); },
        beforeSetDimensions() { ut.callback(this.options.beforeSetDimensions, [this]); },
        setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0; },
        afterSetDimensions() { ut.callback(this.options.afterSetDimensions, [this]); },
        beforeDataLimits() { ut.callback(this.options.beforeDataLimits, [this]); },
        determineDataLimits: ut.noop,
        afterDataLimits() { ut.callback(this.options.afterDataLimits, [this]); },
        beforeBuildTicks() { ut.callback(this.options.beforeBuildTicks, [this]); },
        buildTicks: ut.noop,
        afterBuildTicks(t) { const e = this; return ut.isArray(t) && t.length ? ut.callback(e.options.afterBuildTicks, [e, t]) : (e.ticks = ut.callback(e.options.afterBuildTicks, [e, e.ticks]) || e.ticks, t); },
        beforeTickToLabelConversion() { ut.callback(this.options.beforeTickToLabelConversion, [this]); },
        convertTicksToLabels() { const t = this.options.ticks; this.ticks = this.ticks.map(t.userCallback || t.callback, this); },
        afterTickToLabelConversion() { ut.callback(this.options.afterTickToLabelConversion, [this]); },
        beforeCalculateTickRotation() { ut.callback(this.options.beforeCalculateTickRotation, [this]); },
        calculateTickRotation() { const t = this; const e = t.ctx; const i = t.options.ticks; const n = hi(t._ticks); const a = ut.options._parseFont(i); e.font = a.string; let r = i.minRotation || 0; if (n.length && t.options.display && t.isHorizontal()) for (var o, s = ut.longestText(e, a.string, n, t.longestTextCache), l = s, u = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; l > u && r < i.maxRotation;) { const d = ut.toRadians(r); if (o = Math.cos(d), Math.sin(d) * s > t.maxHeight) { r--; break; }r++, l = o * s; }t.labelRotation = r; },
        afterCalculateTickRotation() { ut.callback(this.options.afterCalculateTickRotation, [this]); },
        beforeFit() { ut.callback(this.options.beforeFit, [this]); },
        fit() { const t = this; const e = t.minSize = { width: 0, height: 0 }; const i = hi(t._ticks); const n = t.options; const a = n.ticks; const r = n.scaleLabel; const o = n.gridLines; const s = t._isVisible(); const l = n.position; const u = t.isHorizontal(); const d = ut.options._parseFont; const h = d(a); const c = n.gridLines.tickMarkLength; if (e.width = u ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : s && o.drawTicks ? c : 0, e.height = u ? s && o.drawTicks ? c : 0 : t.maxHeight, r.display && s) { const f = d(r); const g = ut.options.toPadding(r.padding); const m = f.lineHeight + g.height; u ? e.height += m : e.width += m; } if (a.display && s) { let p = ut.longestText(t.ctx, h.string, i, t.longestTextCache); const v = ut.numberOfLabelLines(i); const y = 0.5 * h.size; const b = t.options.ticks.padding; if (t._maxLabelLines = v, t.longestLabelWidth = p, u) { const x = ut.toRadians(t.labelRotation); const _ = Math.cos(x); const k = Math.sin(x) * p + h.lineHeight * v + y; e.height = Math.min(t.maxHeight, e.height + k + b), t.ctx.font = h.string; let w; let M; const S = ci(t.ctx, i[0], h.string); const D = ci(t.ctx, i[i.length - 1], h.string); const C = t.getPixelForTick(0) - t.left; const P = t.right - t.getPixelForTick(i.length - 1); t.labelRotation !== 0 ? (w = l === "bottom" ? _ * S : _ * y, M = l === "bottom" ? _ * y : _ * D) : (w = S / 2, M = D / 2), t.paddingLeft = Math.max(w - C, 0) + 3, t.paddingRight = Math.max(M - P, 0) + 3; } else a.mirror ? p = 0 : p += b + y, e.width = Math.min(t.maxWidth, e.width + p), t.paddingTop = h.size / 2, t.paddingBottom = h.size / 2; }t.handleMargins(), t.width = e.width, t.height = e.height; },
        handleMargins() { const t = this; t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)); },
        afterFit() { ut.callback(this.options.afterFit, [this]); },
        isHorizontal() { return this.options.position === "top" || this.options.position === "bottom"; },
        isFullWidth() { return this.options.fullWidth; },
        getRightValue(t) { if (ut.isNullOrUndef(t)) return NaN; if ((typeof t === "number" || t instanceof Number) && !isFinite(t)) return NaN; if (t) if (this.isHorizontal()) { if (void 0 !== t.x) return this.getRightValue(t.x); } else if (void 0 !== t.y) return this.getRightValue(t.y); return t; },
        getLabelForIndex: ut.noop,
        getPixelForValue: ut.noop,
        getValueForPixel: ut.noop,
        getPixelForTick(t) { const e = this; const i = e.options.offset; if (e.isHorizontal()) { const n = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (i ? 0 : 1), 1); let a = n * t + e.paddingLeft; i && (a += n / 2); let r = e.left + a; return r += e.isFullWidth() ? e.margins.left : 0; } const o = e.height - (e.paddingTop + e.paddingBottom); return e.top + t * (o / (e._ticks.length - 1)); },
        getPixelForDecimal(t) { const e = this; if (e.isHorizontal()) { const i = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft; let n = e.left + i; return n += e.isFullWidth() ? e.margins.left : 0; } return e.top + t * e.height; },
        getBasePixel() { return this.getPixelForValue(this.getBaseValue()); },
        getBaseValue() { const t = this.min; const e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0; },
        _autoSkip(t) { let e; let i; const n = this; const a = n.isHorizontal(); const r = n.options.ticks.minor; const o = t.length; let s = !1; const l = r.maxTicksLimit; const u = n._tickSize() * (o - 1); const d = a ? n.width - (n.paddingLeft + n.paddingRight) : n.height - (n.paddingTop + n.PaddingBottom); const h = []; for (u > d && (s = 1 + Math.floor(u / d)), o > l && (s = Math.max(s, 1 + Math.floor(o / l))), e = 0; e < o; e++)i = t[e], s > 1 && e % s > 0 && delete i.label, h.push(i); return h; },
        _tickSize() { const t = this; const e = t.isHorizontal(); const i = t.options.ticks.minor; const n = ut.toRadians(t.labelRotation); const a = Math.abs(Math.cos(n)); const r = Math.abs(Math.sin(n)); const o = i.autoSkipPadding || 0; const s = t.longestLabelWidth + o || 0; const l = ut.options._parseFont(i); const u = t._maxLabelLines * l.lineHeight + o || 0; return e ? u * a > s * r ? s / a : u / r : u * r < s * a ? u / a : s / r; },
        _isVisible() { let t; let e; let i; const n = this.chart; const a = this.options.display; if (a !== "auto") return !!a; for (t = 0, e = n.data.datasets.length; t < e; ++t) if (n.isDatasetVisible(t) && ((i = n.getDatasetMeta(t)).xAxisID === this.id || i.yAxisID === this.id)) return !0; return !1; },
        draw(t) {
            const e = this; const i = e.options; if (e._isVisible()) {
                let n; let a; let r; const o = e.chart; const s = e.ctx; const l = ot.global.defaultFontColor; const u = i.ticks.minor; const d = i.ticks.major || u; const h = i.gridLines; const c = i.scaleLabel; const f = i.position; const g = e.labelRotation !== 0; const m = u.mirror; const p = e.isHorizontal(); const v = ut.options._parseFont; const y = u.display && u.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(); const b = ui(u.fontColor, l); const x = v(u); const _ = x.lineHeight; const k = ui(d.fontColor, l); const w = v(d); const M = u.padding; const S = u.labelOffset; const D = h.drawTicks ? h.tickMarkLength : 0; const C = ui(c.fontColor, l); const P = v(c); const T = ut.options.toPadding(c.padding); const O = ut.toRadians(e.labelRotation); const I = []; const A = h.drawBorder ? di(h.lineWidth, 0, 0) : 0; const F = ut._alignPixel; f === "top" ? (n = F(o, e.bottom, A), a = e.bottom - D, r = n - A / 2) : f === "bottom" ? (n = F(o, e.top, A), a = n + A / 2, r = e.top + D) : f === "left" ? (n = F(o, e.right, A), a = e.right - D, r = n - A / 2) : (n = F(o, e.left, A), a = n + A / 2, r = e.left + D); if (ut.each(y, (n, s) => {
                    if (!ut.isNullOrUndef(n.label)) {
                        let l; let u; let d; let c; let v; let y; let b; let x; let k; let w; let C; let P; let T; let R; let L; let W; const Y = n.label; s === e.zeroLineIndex && i.offset === h.offsetGridLines ? (l = h.zeroLineWidth, u = h.zeroLineColor, d = h.zeroLineBorderDash || [], c = h.zeroLineBorderDashOffset || 0) : (l = di(h.lineWidth, s), u = di(h.color, s), d = h.borderDash || [], c = h.borderDashOffset || 0); const N = ut.isArray(Y) ? Y.length : 1; const z = (function (t, e, i) { let n = t.getPixelForTick(e); return i && (t.getTicks().length === 1 ? n -= t.isHorizontal() ? Math.max(n - t.left, t.right - n) : Math.max(n - t.top, t.bottom - n) : n -= e === 0 ? (t.getPixelForTick(1) - n) / 2 : (n - t.getPixelForTick(e - 1)) / 2), n; }(e, s, h.offsetGridLines)); if (p) { const V = D + M; z < e.left - 1e-7 && (u = "rgba(0,0,0,0)"), v = b = k = C = F(o, z, l), y = a, x = r, T = e.getPixelForTick(s) + S, f === "top" ? (w = F(o, t.top, A) + A / 2, P = t.bottom, L = ((g ? 1 : 0.5) - N) * _, W = g ? "left" : "center", R = e.bottom - V) : (w = t.top, P = F(o, t.bottom, A) - A / 2, L = (g ? 0 : 0.5) * _, W = g ? "right" : "center", R = e.top + V); } else { const H = (m ? 0 : D) + M; z < e.top - 1e-7 && (u = "rgba(0,0,0,0)"), v = a, b = r, y = x = w = P = F(o, z, l), R = e.getPixelForTick(s) + S, L = (1 - N) * _ / 2, f === "left" ? (k = F(o, t.left, A) + A / 2, C = t.right, W = m ? "left" : "right", T = e.right - H) : (k = t.left, C = F(o, t.right, A) - A / 2, W = m ? "right" : "left", T = e.left + H); }I.push({
                            tx1: v, ty1: y, tx2: b, ty2: x, x1: k, y1: w, x2: C, y2: P, labelX: T, labelY: R, glWidth: l, glColor: u, glBorderDash: d, glBorderDashOffset: c, rotation: -1 * O, label: Y, major: n.major, textOffset: L, textAlign: W,
                        });
                    }
                }), ut.each(I, (t) => { const e = t.glWidth; const i = t.glColor; if (h.display && e && i && (s.save(), s.lineWidth = e, s.strokeStyle = i, s.setLineDash && (s.setLineDash(t.glBorderDash), s.lineDashOffset = t.glBorderDashOffset), s.beginPath(), h.drawTicks && (s.moveTo(t.tx1, t.ty1), s.lineTo(t.tx2, t.ty2)), h.drawOnChartArea && (s.moveTo(t.x1, t.y1), s.lineTo(t.x2, t.y2)), s.stroke(), s.restore()), u.display) { s.save(), s.translate(t.labelX, t.labelY), s.rotate(t.rotation), s.font = t.major ? w.string : x.string, s.fillStyle = t.major ? k : b, s.textBaseline = "middle", s.textAlign = t.textAlign; const n = t.label; let a = t.textOffset; if (ut.isArray(n)) for (let r = 0; r < n.length; ++r)s.fillText(`${n[r]}`, 0, a), a += _; else s.fillText(n, 0, a); s.restore(); } }), c.display) { let R; let L; let W = 0; const Y = P.lineHeight / 2; if (p)R = e.left + (e.right - e.left) / 2, L = f === "bottom" ? e.bottom - Y - T.bottom : e.top + Y + T.top; else { const N = f === "left"; R = N ? e.left + Y + T.top : e.right - Y - T.top, L = e.top + (e.bottom - e.top) / 2, W = N ? -0.5 * Math.PI : 0.5 * Math.PI; }s.save(), s.translate(R, L), s.rotate(W), s.textAlign = "center", s.textBaseline = "middle", s.fillStyle = C, s.font = P.string, s.fillText(c.labelString, 0, 0), s.restore(); } if (A) { let z; let V; let H; let E; const B = A; const j = di(h.lineWidth, y.length - 1, 0); p ? (z = F(o, e.left, B) - B / 2, V = F(o, e.right, j) + j / 2, H = E = n) : (H = F(o, e.top, B) - B / 2, E = F(o, e.bottom, j) + j / 2, z = V = n), s.lineWidth = A, s.strokeStyle = di(h.color, 0), s.beginPath(), s.moveTo(z, H), s.lineTo(V, E), s.stroke(); }
            }
        },
    }); const gi = fi.extend({
        getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels; }, determineDataLimits() { let t; const e = this; const i = e.getLabels(); e.minIndex = 0, e.maxIndex = i.length - 1, void 0 !== e.options.ticks.min && (t = i.indexOf(e.options.ticks.min), e.minIndex = t !== -1 ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = i.indexOf(e.options.ticks.max), e.maxIndex = t !== -1 ? t : e.maxIndex), e.min = i[e.minIndex], e.max = i[e.maxIndex]; }, buildTicks() { const t = this; const e = t.getLabels(); t.ticks = t.minIndex === 0 && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1); }, getLabelForIndex(t, e) { const i = this; const n = i.chart; return n.getDatasetMeta(e).controller._getValueScaleId() === i.id ? i.getRightValue(n.data.datasets[e].data[t]) : i.ticks[t - i.minIndex]; }, getPixelForValue(t, e) { let i; const n = this; const a = n.options.offset; const r = Math.max(n.maxIndex + 1 - n.minIndex - (a ? 0 : 1), 1); if (t != null && (i = n.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) { t = i || t; const o = n.getLabels().indexOf(t); e = o !== -1 ? o : e; } if (n.isHorizontal()) { const s = n.width / r; let l = s * (e - n.minIndex); return a && (l += s / 2), n.left + l; } const u = n.height / r; let d = u * (e - n.minIndex); return a && (d += u / 2), n.top + d; }, getPixelForTick(t) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null); }, getValueForPixel(t) { const e = this; const i = e.options.offset; const n = Math.max(e._ticks.length - (i ? 0 : 1), 1); const a = e.isHorizontal(); const r = (a ? e.width : e.height) / n; return t -= a ? e.left : e.top, i && (t -= r / 2), (t <= 0 ? 0 : Math.round(t / r)) + e.minIndex; }, getBasePixel() { return this.bottom; },
    }); const mi = { position: "bottom" }; gi._defaults = mi; const pi = ut.noop; const vi = ut.isNullOrUndef; const yi = fi.extend({
        getRightValue(t) { return typeof t === "string" ? +t : fi.prototype.getRightValue.call(this, t); },
        handleTickRangeOptions() { const t = this; const e = t.options.ticks; if (e.beginAtZero) { const i = ut.sign(t.min); const n = ut.sign(t.max); i < 0 && n < 0 ? t.max = 0 : i > 0 && n > 0 && (t.min = 0); } const a = void 0 !== e.min || void 0 !== e.suggestedMin; const r = void 0 !== e.max || void 0 !== e.suggestedMax; void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (t.min === null ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (t.max === null ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), a !== r && t.min >= t.max && (a ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--); },
        getTickLimit() { let t; const e = this.options.ticks; const i = e.stepSize; let n = e.maxTicksLimit; return i ? t = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1 : (t = this._computeTickLimit(), n = n || 11), n && (t = Math.min(n, t)), t; },
        _computeTickLimit() { return Number.POSITIVE_INFINITY; },
        handleDirectionalChanges: pi,
        buildTicks() {
            const t = this; const e = t.options.ticks; let i = t.getTickLimit(); const n = {
                maxTicks: i = Math.max(2, i), min: e.min, max: e.max, precision: e.precision, stepSize: ut.valueOrDefault(e.fixedStepSize, e.stepSize),
            }; const a = t.ticks = (function (t, e) { let i; let n; let a; let r; const o = []; const s = t.stepSize; const l = s || 1; const u = t.maxTicks - 1; const d = t.min; const h = t.max; const c = t.precision; const f = e.min; const g = e.max; let m = ut.niceNum((g - f) / u / l) * l; if (m < 1e-14 && vi(d) && vi(h)) return [f, g]; (r = Math.ceil(g / m) - Math.floor(f / m)) > u && (m = ut.niceNum(r * m / u / l) * l), s || vi(c) ? i = Math.pow(10, ut._decimalPlaces(m)) : (i = Math.pow(10, c), m = Math.ceil(m * i) / i), n = Math.floor(f / m) * m, a = Math.ceil(g / m) * m, s && (!vi(d) && ut.almostWhole(d / m, m / 1e3) && (n = d), !vi(h) && ut.almostWhole(h / m, m / 1e3) && (a = h)), r = (a - n) / m, r = ut.almostEquals(r, Math.round(r), m / 1e3) ? Math.round(r) : Math.ceil(r), n = Math.round(n * i) / i, a = Math.round(a * i) / i, o.push(vi(d) ? n : d); for (let p = 1; p < r; ++p)o.push(Math.round((n + p * m) * i) / i); return o.push(vi(h) ? a : h), o; }(n, t)); t.handleDirectionalChanges(), t.max = ut.max(a), t.min = ut.min(a), e.reverse ? (a.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
        },
        convertTicksToLabels() { const t = this; t.ticksAsNumbers = t.ticks.slice(), t.zeroLineIndex = t.ticks.indexOf(0), fi.prototype.convertTicksToLabels.call(t); },
    }); const bi = { position: "left", ticks: { callback: li.formatters.linear } }; const xi = yi.extend({
        determineDataLimits() { const t = this; const e = t.options; const i = t.chart; const n = i.data.datasets; const a = t.isHorizontal(); function r(e) { return a ? e.xAxisID === t.id : e.yAxisID === t.id; }t.min = null, t.max = null; let o = e.stacked; if (void 0 === o && ut.each(n, (t, e) => { if (!o) { const n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (o = !0); } }), e.stacked || o) { const s = {}; ut.each(n, (n, a) => { const o = i.getDatasetMeta(a); const l = [o.type, void 0 === e.stacked && void 0 === o.stack ? a : "", o.stack].join("."); void 0 === s[l] && (s[l] = { positiveValues: [], negativeValues: [] }); const u = s[l].positiveValues; const d = s[l].negativeValues; i.isDatasetVisible(a) && r(o) && ut.each(n.data, (i, n) => { const a = +t.getRightValue(i); isNaN(a) || o.data[n].hidden || (u[n] = u[n] || 0, d[n] = d[n] || 0, e.relativePoints ? u[n] = 100 : a < 0 ? d[n] += a : u[n] += a); }); }), ut.each(s, (e) => { const i = e.positiveValues.concat(e.negativeValues); const n = ut.min(i); const a = ut.max(i); t.min = t.min === null ? n : Math.min(t.min, n), t.max = t.max === null ? a : Math.max(t.max, a); }); } else ut.each(n, (e, n) => { const a = i.getDatasetMeta(n); i.isDatasetVisible(n) && r(a) && ut.each(e.data, (e, i) => { const n = +t.getRightValue(e); isNaN(n) || a.data[i].hidden || (t.min === null ? t.min = n : n < t.min && (t.min = n), t.max === null ? t.max = n : n > t.max && (t.max = n)); }); }); t.min = isFinite(t.min) && !isNaN(t.min) ? t.min : 0, t.max = isFinite(t.max) && !isNaN(t.max) ? t.max : 1, this.handleTickRangeOptions(); }, _computeTickLimit() { let t; return this.isHorizontal() ? Math.ceil(this.width / 40) : (t = ut.options._parseFont(this.options.ticks), Math.ceil(this.height / t.lineHeight)); }, handleDirectionalChanges() { this.isHorizontal() || this.ticks.reverse(); }, getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, getPixelForValue(t) { const e = this; const i = e.start; const n = +e.getRightValue(t); const a = e.end - i; return e.isHorizontal() ? e.left + e.width / a * (n - i) : e.bottom - e.height / a * (n - i); }, getValueForPixel(t) { const e = this; const i = e.isHorizontal(); const n = i ? e.width : e.height; const a = (i ? t - e.left : e.bottom - t) / n; return e.start + (e.end - e.start) * a; }, getPixelForTick(t) { return this.getPixelForValue(this.ticksAsNumbers[t]); },
    }); const _i = bi; xi._defaults = _i; const ki = ut.valueOrDefault; const wi = { position: "left", ticks: { callback: li.formatters.logarithmic } }; function Mi(t, e) { return ut.isFinite(t) && t >= 0 ? t : e; } const Si = fi.extend({
        determineDataLimits() { const t = this; const e = t.options; const i = t.chart; const n = i.data.datasets; const a = t.isHorizontal(); function r(e) { return a ? e.xAxisID === t.id : e.yAxisID === t.id; }t.min = null, t.max = null, t.minNotZero = null; let o = e.stacked; if (void 0 === o && ut.each(n, (t, e) => { if (!o) { const n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (o = !0); } }), e.stacked || o) { const s = {}; ut.each(n, (n, a) => { const o = i.getDatasetMeta(a); const l = [o.type, void 0 === e.stacked && void 0 === o.stack ? a : "", o.stack].join("."); i.isDatasetVisible(a) && r(o) && (void 0 === s[l] && (s[l] = []), ut.each(n.data, (e, i) => { const n = s[l]; const a = +t.getRightValue(e); isNaN(a) || o.data[i].hidden || a < 0 || (n[i] = n[i] || 0, n[i] += a); })); }), ut.each(s, (e) => { if (e.length > 0) { const i = ut.min(e); const n = ut.max(e); t.min = t.min === null ? i : Math.min(t.min, i), t.max = t.max === null ? n : Math.max(t.max, n); } }); } else ut.each(n, (e, n) => { const a = i.getDatasetMeta(n); i.isDatasetVisible(n) && r(a) && ut.each(e.data, (e, i) => { const n = +t.getRightValue(e); isNaN(n) || a.data[i].hidden || n < 0 || (t.min === null ? t.min = n : n < t.min && (t.min = n), t.max === null ? t.max = n : n > t.max && (t.max = n), n !== 0 && (t.minNotZero === null || n < t.minNotZero) && (t.minNotZero = n)); }); }); this.handleTickRangeOptions(); }, handleTickRangeOptions() { const t = this; const e = t.options.ticks; t.min = Mi(e.min, t.min), t.max = Mi(e.max, t.max), t.min === t.max && (t.min !== 0 && t.min !== null ? (t.min = Math.pow(10, Math.floor(ut.log10(t.min)) - 1), t.max = Math.pow(10, Math.floor(ut.log10(t.max)) + 1)) : (t.min = 1, t.max = 10)), t.min === null && (t.min = Math.pow(10, Math.floor(ut.log10(t.max)) - 1)), t.max === null && (t.max = t.min !== 0 ? Math.pow(10, Math.floor(ut.log10(t.min)) + 1) : 10), t.minNotZero === null && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = Math.pow(10, Math.floor(ut.log10(t.max))) : t.minNotZero = 1); }, buildTicks() { const t = this; const e = t.options.ticks; let i = !t.isHorizontal(); const n = { min: Mi(e.min), max: Mi(e.max) }; const a = t.ticks = (function (t, e) { let i; let n; const a = []; let r = ki(t.min, Math.pow(10, Math.floor(ut.log10(e.min)))); const o = Math.floor(ut.log10(e.max)); const s = Math.ceil(e.max / Math.pow(10, o)); r === 0 ? (i = Math.floor(ut.log10(e.minNotZero)), n = Math.floor(e.minNotZero / Math.pow(10, i)), a.push(r), r = n * Math.pow(10, i)) : (i = Math.floor(ut.log10(r)), n = Math.floor(r / Math.pow(10, i))); let l = i < 0 ? Math.pow(10, Math.abs(i)) : 1; do { a.push(r), ++n == 10 && (n = 1, l = ++i >= 0 ? 1 : l), r = Math.round(n * Math.pow(10, i) * l) / l; } while (i < o || i === o && n < s); const u = ki(t.max, r); return a.push(u), a; }(n, t)); t.max = ut.max(a), t.min = ut.min(a), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && a.reverse(); }, convertTicksToLabels() { this.tickValues = this.ticks.slice(), fi.prototype.convertTicksToLabels.call(this); }, getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, getPixelForTick(t) { return this.getPixelForValue(this.tickValues[t]); }, _getFirstTickValue(t) { const e = Math.floor(ut.log10(t)); return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e); }, getPixelForValue(t) { let e; let i; let n; let a; let r; const o = this; const s = o.options.ticks; const l = s.reverse; const u = ut.log10; const d = o._getFirstTickValue(o.minNotZero); let h = 0; return t = +o.getRightValue(t), l ? (n = o.end, a = o.start, r = -1) : (n = o.start, a = o.end, r = 1), o.isHorizontal() ? (e = o.width, i = l ? o.right : o.left) : (e = o.height, r *= -1, i = l ? o.top : o.bottom), t !== n && (n === 0 && (e -= h = ki(s.fontSize, ot.global.defaultFontSize), n = d), t !== 0 && (h += e / (u(a) - u(n)) * (u(t) - u(n))), i += r * h), i; }, getValueForPixel(t) { let e; let i; let n; let a; const r = this; const o = r.options.ticks; const s = o.reverse; const l = ut.log10; const u = r._getFirstTickValue(r.minNotZero); if (s ? (i = r.end, n = r.start) : (i = r.start, n = r.end), r.isHorizontal() ? (e = r.width, a = s ? r.right - t : t - r.left) : (e = r.height, a = s ? t - r.top : r.bottom - t), a !== i) { if (i === 0) { const d = ki(o.fontSize, ot.global.defaultFontSize); a -= d, e -= d, i = u; }a *= l(n) - l(i), a /= e, a = Math.pow(10, l(i) + a); } return a; },
    }); const Di = wi; Si._defaults = Di; const Ci = ut.valueOrDefault; const Pi = ut.valueAtIndexOrDefault; const Ti = ut.options.resolve; const Oi = {
        display: !0,
        animate: !0,
        position: "chartArea",
        angleLines: {
            display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, borderDash: [], borderDashOffset: 0,
        },
        gridLines: { circular: !1 },
        ticks: {
            showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: li.formatters.linear,
        },
        pointLabels: { display: !0, fontSize: 10, callback(t) { return t; } },
    }; function Ii(t) { const e = t.options; return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0; } function Ai(t) { const e = t.ticks; return e.display && t.display ? Ci(e.fontSize, ot.global.defaultFontSize) + 2 * e.backdropPaddingY : 0; } function Fi(t, e, i, n, a) { return t === n || t === a ? { start: e - i / 2, end: e + i / 2 } : t < n || t > a ? { start: e - i, end: e } : { start: e, end: e + i }; } function Ri(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right"; } function Li(t, e, i, n) { let a; let r; let o = i.y + n / 2; if (ut.isArray(e)) for (a = 0, r = e.length; a < r; ++a)t.fillText(e[a], i.x, o), o += n; else t.fillText(e, i.x, o); } function Wi(t, e, i) { t === 90 || t === 270 ? i.y -= e.h / 2 : (t > 270 || t < 90) && (i.y -= e.h); } function Yi(t) { return ut.isNumber(t) ? t : 0; } const Ni = yi.extend({
        setDimensions() { const t = this; t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = Ai(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2; },
        determineDataLimits() { const t = this; const e = t.chart; let i = Number.POSITIVE_INFINITY; let n = Number.NEGATIVE_INFINITY; ut.each(e.data.datasets, (a, r) => { if (e.isDatasetVisible(r)) { const o = e.getDatasetMeta(r); ut.each(a.data, (e, a) => { const r = +t.getRightValue(e); isNaN(r) || o.data[a].hidden || (i = Math.min(r, i), n = Math.max(r, n)); }); } }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions(); },
        _computeTickLimit() { return Math.ceil(this.drawingArea / Ai(this.options)); },
        convertTicksToLabels() { const t = this; yi.prototype.convertTicksToLabels.call(t), t.pointLabels = t.chart.data.labels.map(t.options.pointLabels.callback, t); },
        getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); },
        fit() {
            const t = this.options; t.display && t.pointLabels.display ? (function (t) {
                let e; let i; let n; const a = ut.options._parseFont(t.options.pointLabels); const r = {
                    l: 0, r: t.width, t: 0, b: t.height - t.paddingTop,
                }; const o = {}; t.ctx.font = a.string, t._pointLabelSizes = []; let s; let l; let u; const d = Ii(t); for (e = 0; e < d; e++) { n = t.getPointPosition(e, t.drawingArea + 5), s = t.ctx, l = a.lineHeight, u = t.pointLabels[e] || "", i = ut.isArray(u) ? { w: ut.longestText(s, s.font, u), h: u.length * l } : { w: s.measureText(u).width, h: l }, t._pointLabelSizes[e] = i; const h = t.getIndexAngle(e); const c = ut.toDegrees(h) % 360; const f = Fi(c, n.x, i.w, 0, 180); const g = Fi(c, n.y, i.h, 90, 270); f.start < r.l && (r.l = f.start, o.l = h), f.end > r.r && (r.r = f.end, o.r = h), g.start < r.t && (r.t = g.start, o.t = h), g.end > r.b && (r.b = g.end, o.b = h); }t.setReductions(t.drawingArea, r, o);
            }(this)) : this.setCenterPoint(0, 0, 0, 0);
        },
        setReductions(t, e, i) { const n = this; let a = e.l / Math.sin(i.l); let r = Math.max(e.r - n.width, 0) / Math.sin(i.r); let o = -e.t / Math.cos(i.t); let s = -Math.max(e.b - (n.height - n.paddingTop), 0) / Math.cos(i.b); a = Yi(a), r = Yi(r), o = Yi(o), s = Yi(s), n.drawingArea = Math.min(Math.floor(t - (a + r) / 2), Math.floor(t - (o + s) / 2)), n.setCenterPoint(a, r, o, s); },
        setCenterPoint(t, e, i, n) { const a = this; const r = a.width - e - a.drawingArea; const o = t + a.drawingArea; const s = i + a.drawingArea; const l = a.height - a.paddingTop - n - a.drawingArea; a.xCenter = Math.floor((o + r) / 2 + a.left), a.yCenter = Math.floor((s + l) / 2 + a.top + a.paddingTop); },
        getIndexAngle(t) { return t * (2 * Math.PI / Ii(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360; },
        getDistanceFromCenterForValue(t) { const e = this; if (t === null) return 0; const i = e.drawingArea / (e.max - e.min); return e.options.ticks.reverse ? (e.max - t) * i : (t - e.min) * i; },
        getPointPosition(t, e) { const i = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.cos(i) * e + this.xCenter, y: Math.sin(i) * e + this.yCenter }; },
        getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)); },
        getBasePosition() { const t = this.min; const e = this.max; return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0); },
        draw() { const t = this; const e = t.options; const i = e.gridLines; const n = e.ticks; if (e.display) { const a = t.ctx; const r = this.getIndexAngle(0); const o = ut.options._parseFont(n); (e.angleLines.display || e.pointLabels.display) && (function (t) { const e = t.ctx; const i = t.options; const n = i.angleLines; const a = i.gridLines; const r = i.pointLabels; const o = Ci(n.lineWidth, a.lineWidth); const s = Ci(n.color, a.color); const l = Ai(i); e.save(), e.lineWidth = o, e.strokeStyle = s, e.setLineDash && (e.setLineDash(Ti([n.borderDash, a.borderDash, []])), e.lineDashOffset = Ti([n.borderDashOffset, a.borderDashOffset, 0])); const u = t.getDistanceFromCenterForValue(i.ticks.reverse ? t.min : t.max); const d = ut.options._parseFont(r); e.font = d.string, e.textBaseline = "middle"; for (let h = Ii(t) - 1; h >= 0; h--) { if (n.display && o && s) { const c = t.getPointPosition(h, u); e.beginPath(), e.moveTo(t.xCenter, t.yCenter), e.lineTo(c.x, c.y), e.stroke(); } if (r.display) { const f = h === 0 ? l / 2 : 0; const g = t.getPointPosition(h, u + f + 5); const m = Pi(r.fontColor, h, ot.global.defaultFontColor); e.fillStyle = m; const p = t.getIndexAngle(h); const v = ut.toDegrees(p); e.textAlign = Ri(v), Wi(v, t._pointLabelSizes[h], g), Li(e, t.pointLabels[h] || "", g, d.lineHeight); } }e.restore(); }(t)), ut.each(t.ticks, (e, s) => { if (s > 0 || n.reverse) { const l = t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]); if (i.display && s !== 0 && (function (t, e, i, n) { let a; const r = t.ctx; const o = e.circular; const s = Ii(t); const l = Pi(e.color, n - 1); const u = Pi(e.lineWidth, n - 1); if ((o || s) && l && u) { if (r.save(), r.strokeStyle = l, r.lineWidth = u, r.setLineDash && (r.setLineDash(e.borderDash || []), r.lineDashOffset = e.borderDashOffset || 0), r.beginPath(), o)r.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI); else { a = t.getPointPosition(0, i), r.moveTo(a.x, a.y); for (let d = 1; d < s; d++)a = t.getPointPosition(d, i), r.lineTo(a.x, a.y); }r.closePath(), r.stroke(), r.restore(); } }(t, i, l, s)), n.display) { const u = Ci(n.fontColor, ot.global.defaultFontColor); if (a.font = o.string, a.save(), a.translate(t.xCenter, t.yCenter), a.rotate(r), n.showLabelBackdrop) { const d = a.measureText(e).width; a.fillStyle = n.backdropColor, a.fillRect(-d / 2 - n.backdropPaddingX, -l - o.size / 2 - n.backdropPaddingY, d + 2 * n.backdropPaddingX, o.size + 2 * n.backdropPaddingY); }a.textAlign = "center", a.textBaseline = "middle", a.fillStyle = u, a.fillText(e, 0, -l), a.restore(); } } }); } },
    }); const zi = Oi; Ni._defaults = zi; const Vi = ut.valueOrDefault; const Hi = Number.MIN_SAFE_INTEGER || -9007199254740991; const Ei = Number.MAX_SAFE_INTEGER || 9007199254740991; const Bi = {
        millisecond: { common: !0, size: 1, steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, second: { common: !0, size: 1e3, steps: [1, 2, 5, 10, 15, 30] }, minute: { common: !0, size: 6e4, steps: [1, 2, 5, 10, 15, 30] }, hour: { common: !0, size: 36e5, steps: [1, 2, 3, 6, 12] }, day: { common: !0, size: 864e5, steps: [1, 2, 5] }, week: { common: !1, size: 6048e5, steps: [1, 2, 3, 4] }, month: { common: !0, size: 2628e6, steps: [1, 2, 3] }, quarter: { common: !1, size: 7884e6, steps: [1, 2, 3, 4] }, year: { common: !0, size: 3154e7 },
    }; const ji = Object.keys(Bi); function Ui(t, e) { return t - e; } function Gi(t) { let e; let i; let n; const a = {}; const r = []; for (e = 0, i = t.length; e < i; ++e)a[n = t[e]] || (a[n] = !0, r.push(n)); return r; } function qi(t, e, i, n) { const a = (function (t, e, i) { for (var n, a, r, o = 0, s = t.length - 1; o >= 0 && o <= s;) { if (a = t[(n = o + s >> 1) - 1] || null, r = t[n], !a) return { lo: null, hi: r }; if (r[e] < i)o = n + 1; else { if (!(a[e] > i)) return { lo: a, hi: r }; s = n - 1; } } return { lo: r, hi: null }; }(t, e, i)); const r = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0]; const o = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1]; const s = o[e] - r[e]; const l = s ? (i - r[e]) / s : 0; const u = (o[n] - r[n]) * l; return r[n] + u; } function Zi(t, e) { const i = t._adapter; const n = t.options.time; const a = n.parser; const r = a || n.format; let o = e; return typeof a === "function" && (o = a(o)), ut.isFinite(o) || (o = typeof r === "string" ? i.parse(o, r) : i.parse(o)), o !== null ? +o : (a || typeof r !== "function" || (o = r(e), ut.isFinite(o) || (o = i.parse(o))), o); } function $i(t, e) { if (ut.isNullOrUndef(e)) return null; const i = t.options.time; let n = Zi(t, t.getRightValue(e)); return n === null ? n : (i.round && (n = +t._adapter.startOf(n, i.round)), n); } function Xi(t) { for (let e = ji.indexOf(t) + 1, i = ji.length; e < i; ++e) if (Bi[ji[e]].common) return ji[e]; } function Ki(t, e, i, n) { let a; const r = t._adapter; const o = t.options; const s = o.time; const l = s.unit || (function (t, e, i, n) { let a; let r; let o; const s = ji.length; for (a = ji.indexOf(t); a < s - 1; ++a) if (o = (r = Bi[ji[a]]).steps ? r.steps[r.steps.length - 1] : Ei, r.common && Math.ceil((i - e) / (o * r.size)) <= n) return ji[a]; return ji[s - 1]; }(s.minUnit, e, i, n)); const u = Xi(l); let d = Vi(s.stepSize, s.unitStepSize); const h = l === "week" && s.isoWeekday; const c = o.ticks.major.enabled; const f = Bi[l]; let g = e; let m = i; const p = []; for (d || (d = (function (t, e, i, n) { let a; let r; let o; const s = e - t; const l = Bi[i]; const u = l.size; const d = l.steps; if (!d) return Math.ceil(s / (n * u)); for (a = 0, r = d.length; a < r && (o = d[a], !(Math.ceil(s / (u * o)) <= n)); ++a);return o; }(e, i, l, n))), h && (g = +r.startOf(g, "isoWeek", h), m = +r.startOf(m, "isoWeek", h)), g = +r.startOf(g, h ? "day" : l), (m = +r.startOf(m, h ? "day" : l)) < i && (m = +r.add(m, 1, l)), a = g, c && u && !h && !s.round && (a = +r.startOf(a, u), a = +r.add(a, ~~((g - a) / (f.size * d)) * d, l)); a < m; a = +r.add(a, d, l))p.push(+a); return p.push(+a), p; } const Ji = fi.extend({
        initialize() { this.mergeTicksOptions(), fi.prototype.initialize.call(this); }, update() { const t = this.options; const e = t.time || (t.time = {}); const i = this._adapter = new si._date(t.adapters.date); return e.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), ut.mergeIf(e.displayFormats, i.formats()), fi.prototype.update.apply(this, arguments); }, getRightValue(t) { return t && void 0 !== t.t && (t = t.t), fi.prototype.getRightValue.call(this, t); }, determineDataLimits() { let t; let e; let i; let n; let a; let r; const o = this; const s = o.chart; const l = o._adapter; const u = o.options.time; const d = u.unit || "day"; let h = Ei; let c = Hi; let f = []; const g = []; let m = []; const p = s.data.labels || []; for (t = 0, i = p.length; t < i; ++t)m.push($i(o, p[t])); for (t = 0, i = (s.data.datasets || []).length; t < i; ++t) if (s.isDatasetVisible(t)) if (a = s.data.datasets[t].data, ut.isObject(a[0])) for (g[t] = [], e = 0, n = a.length; e < n; ++e)r = $i(o, a[e]), f.push(r), g[t][e] = r; else { for (e = 0, n = m.length; e < n; ++e)f.push(m[e]); g[t] = m.slice(0); } else g[t] = []; m.length && (m = Gi(m).sort(Ui), h = Math.min(h, m[0]), c = Math.max(c, m[m.length - 1])), f.length && (f = Gi(f).sort(Ui), h = Math.min(h, f[0]), c = Math.max(c, f[f.length - 1])), h = $i(o, u.min) || h, c = $i(o, u.max) || c, h = h === Ei ? +l.startOf(Date.now(), d) : h, c = c === Hi ? +l.endOf(Date.now(), d) + 1 : c, o.min = Math.min(h, c), o.max = Math.max(h + 1, c), o._horizontal = o.isHorizontal(), o._table = [], o._timestamps = { data: f, datasets: g, labels: m }; }, buildTicks() { let t; let e; let i; const n = this; let a = n.min; let r = n.max; const o = n.options; const s = o.time; let l = []; const u = []; switch (o.ticks.source) { case "data": l = n._timestamps.data; break; case "labels": l = n._timestamps.labels; break; case "auto": default: l = Ki(n, a, r, n.getLabelCapacity(a)); } for (o.bounds === "ticks" && l.length && (a = l[0], r = l[l.length - 1]), a = $i(n, s.min) || a, r = $i(n, s.max) || r, t = 0, e = l.length; t < e; ++t)(i = l[t]) >= a && i <= r && u.push(i); return n.min = a, n.max = r, n._unit = s.unit || (function (t, e, i, n, a) { let r; let o; for (r = ji.length - 1; r >= ji.indexOf(i); r--) if (o = ji[r], Bi[o].common && t._adapter.diff(a, n, o) >= e.length) return o; return ji[i ? ji.indexOf(i) : 0]; }(n, u, s.minUnit, n.min, n.max)), n._majorUnit = Xi(n._unit), n._table = (function (t, e, i, n) { if (n === "linear" || !t.length) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; let a; let r; let o; let s; let l; const u = []; const d = [e]; for (a = 0, r = t.length; a < r; ++a)(s = t[a]) > e && s < i && d.push(s); for (d.push(i), a = 0, r = d.length; a < r; ++a)l = d[a + 1], o = d[a - 1], s = d[a], void 0 !== o && void 0 !== l && Math.round((l + o) / 2) === s || u.push({ time: s, pos: a / (r - 1) }); return u; }(n._timestamps.data, a, r, o.distribution)), n._offsets = (function (t, e, i, n, a) { let r; let o; let s = 0; let l = 0; return a.offset && e.length && (a.time.min || (r = qi(t, "time", e[0], "pos"), s = e.length === 1 ? 1 - r : (qi(t, "time", e[1], "pos") - r) / 2), a.time.max || (o = qi(t, "time", e[e.length - 1], "pos"), l = e.length === 1 ? o : (o - qi(t, "time", e[e.length - 2], "pos")) / 2)), { start: s, end: l }; }(n._table, u, 0, 0, o)), o.ticks.reverse && u.reverse(), (function (t, e, i) { let n; let a; let r; let o; const s = []; for (n = 0, a = e.length; n < a; ++n)r = e[n], o = !!i && r === +t._adapter.startOf(r, i), s.push({ value: r, major: o }); return s; }(n, u, n._majorUnit)); }, getLabelForIndex(t, e) { const i = this; const n = i._adapter; const a = i.chart.data; const r = i.options.time; let o = a.labels && t < a.labels.length ? a.labels[t] : ""; const s = a.datasets[e].data[t]; return ut.isObject(s) && (o = i.getRightValue(s)), r.tooltipFormat ? n.format(Zi(i, o), r.tooltipFormat) : typeof o === "string" ? o : n.format(Zi(i, o), r.displayFormats.datetime); }, tickFormatFunction(t, e, i, n) { const a = this._adapter; const r = this.options; const o = r.time.displayFormats; const s = o[this._unit]; const l = this._majorUnit; const u = o[l]; const d = +a.startOf(t, l); const h = r.ticks.major; const c = h.enabled && l && u && t === d; const f = a.format(t, n || (c ? u : s)); const g = c ? h : r.ticks.minor; const m = Vi(g.callback, g.userCallback); return m ? m(f, e, i) : f; }, convertTicksToLabels(t) { let e; let i; const n = []; for (e = 0, i = t.length; e < i; ++e)n.push(this.tickFormatFunction(t[e].value, e, t)); return n; }, getPixelForOffset(t) { const e = this; const i = e.options.ticks.reverse; const n = e._horizontal ? e.width : e.height; const a = e._horizontal ? i ? e.right : e.left : i ? e.bottom : e.top; const r = qi(e._table, "time", t, "pos"); const o = n * (e._offsets.start + r) / (e._offsets.start + 1 + e._offsets.end); return i ? a - o : a + o; }, getPixelForValue(t, e, i) { let n = null; if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), n === null && (n = $i(this, t)), n !== null) return this.getPixelForOffset(n); }, getPixelForTick(t) { const e = this.getTicks(); return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null; }, getValueForPixel(t) { const e = this; const i = e._horizontal ? e.width : e.height; const n = e._horizontal ? e.left : e.top; const a = (i ? (t - n) / i : 0) * (e._offsets.start + 1 + e._offsets.start) - e._offsets.end; const r = qi(e._table, "pos", a, "time"); return e._adapter._create(r); }, getLabelWidth(t) { const e = this.options.ticks; const i = this.ctx.measureText(t).width; const n = ut.toRadians(e.maxRotation); const a = Math.cos(n); const r = Math.sin(n); return i * a + Vi(e.fontSize, ot.global.defaultFontSize) * r; }, getLabelCapacity(t) { const e = this; const i = e.options.time.displayFormats.millisecond; const n = e.tickFormatFunction(t, 0, [], i); const a = e.getLabelWidth(n); const r = e.isHorizontal() ? e.width : e.height; const o = Math.floor(r / a); return o > 0 ? o : 1; },
    }); const Qi = {
        position: "bottom",
        distribution: "linear",
        bounds: "data",
        adapters: {},
        time: {
            parser: !1, format: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {},
        },
        ticks: { autoSkip: !1, source: "auto", major: { enabled: !1 } },
    }; Ji._defaults = Qi; let tn; const en = {
        category: gi, linear: xi, logarithmic: Si, radialLinear: Ni, time: Ji,
    }; const nn = ((function (t, e) {
        t.exports = (function () {
            let e; let i; function n() { return e.apply(null, arguments); } function a(t) { return t instanceof Array || Object.prototype.toString.call(t) === "[object Array]"; } function r(t) { return t != null && Object.prototype.toString.call(t) === "[object Object]"; } function o(t) { return void 0 === t; } function s(t) { return typeof t === "number" || Object.prototype.toString.call(t) === "[object Number]"; } function l(t) { return t instanceof Date || Object.prototype.toString.call(t) === "[object Date]"; } function u(t, e) { let i; const n = []; for (i = 0; i < t.length; ++i)n.push(e(t[i], i)); return n; } function d(t, e) { return Object.prototype.hasOwnProperty.call(t, e); } function h(t, e) { for (const i in e)d(e, i) && (t[i] = e[i]); return d(e, "toString") && (t.toString = e.toString), d(e, "valueOf") && (t.valueOf = e.valueOf), t; } function c(t, e, i, n) { return Oe(t, e, i, n, !0).utc(); } function f(t) {
                return t._pf == null && (t._pf = {
                    empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], meridiem: null, rfc2822: !1, weekdayMismatch: !1,
                }), t._pf;
            } function g(t) { if (t._isValid == null) { const e = f(t); const n = i.call(e.parsedDateParts, (t) => t != null); let a = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && n); if (t._strict && (a = a && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && void 0 === e.bigHour), Object.isFrozen != null && Object.isFrozen(t)) return a; t._isValid = a; } return t._isValid; } function m(t) { const e = c(NaN); return t != null ? h(f(e), t) : f(e).userInvalidated = !0, e; }i = Array.prototype.some ? Array.prototype.some : function (t) { for (let e = Object(this), i = e.length >>> 0, n = 0; n < i; n++) if (n in e && t.call(this, e[n], n, e)) return !0; return !1; }; const p = n.momentProperties = []; function v(t, e) { let i; let n; let a; if (o(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), o(e._i) || (t._i = e._i), o(e._f) || (t._f = e._f), o(e._l) || (t._l = e._l), o(e._strict) || (t._strict = e._strict), o(e._tzm) || (t._tzm = e._tzm), o(e._isUTC) || (t._isUTC = e._isUTC), o(e._offset) || (t._offset = e._offset), o(e._pf) || (t._pf = f(e)), o(e._locale) || (t._locale = e._locale), p.length > 0) for (i = 0; i < p.length; i++)n = p[i], o(a = e[n]) || (t[n] = a); return t; } let y = !1; function b(t) { v(this, t), this._d = new Date(t._d != null ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === y && (y = !0, n.updateOffset(this), y = !1); } function x(t) { return t instanceof b || t != null && t._isAMomentObject != null; } function _(t) { return t < 0 ? Math.ceil(t) || 0 : Math.floor(t); } function k(t) { const e = +t; let i = 0; return e !== 0 && isFinite(e) && (i = _(e)), i; } function w(t, e, i) { let n; const a = Math.min(t.length, e.length); const r = Math.abs(t.length - e.length); let o = 0; for (n = 0; n < a; n++)(i && t[n] !== e[n] || !i && k(t[n]) !== k(e[n])) && o++; return o + r; } function M(t) { !1 === n.suppressDeprecationWarnings && typeof console !== "undefined" && console.warn && console.warn(`Deprecation warning: ${t}`); } function S(t, e) { let i = !0; return h(function () { if (n.deprecationHandler != null && n.deprecationHandler(null, t), i) { for (var a, r = [], o = 0; o < arguments.length; o++) { if (a = "", typeof arguments[o] === "object") { for (const s in a += `\n[${o}] `, arguments[0])a += `${s}: ${arguments[0][s]}, `; a = a.slice(0, -2); } else a = arguments[o]; r.push(a); }M(`${t}\nArguments: ${Array.prototype.slice.call(r).join("")}\n${(new Error()).stack}`), i = !1; } return e.apply(this, arguments); }, e); } let D; const C = {}; function P(t, e) { n.deprecationHandler != null && n.deprecationHandler(t, e), C[t] || (M(e), C[t] = !0); } function T(t) { return t instanceof Function || Object.prototype.toString.call(t) === "[object Function]"; } function O(t, e) { let i; const n = h({}, t); for (i in e)d(e, i) && (r(t[i]) && r(e[i]) ? (n[i] = {}, h(n[i], t[i]), h(n[i], e[i])) : e[i] != null ? n[i] = e[i] : delete n[i]); for (i in t)d(t, i) && !d(e, i) && r(t[i]) && (n[i] = h({}, n[i])); return n; } function I(t) { t != null && this.set(t); }n.suppressDeprecationWarnings = !1, n.deprecationHandler = null, D = Object.keys ? Object.keys : function (t) { let e; const i = []; for (e in t)d(t, e) && i.push(e); return i; }; const A = {}; function F(t, e) { const i = t.toLowerCase(); A[i] = A[`${i}s`] = A[e] = t; } function R(t) { return typeof t === "string" ? A[t] || A[t.toLowerCase()] : void 0; } function L(t) { let e; let i; const n = {}; for (i in t)d(t, i) && (e = R(i)) && (n[e] = t[i]); return n; } const W = {}; function Y(t, e) { W[t] = e; } function N(t, e, i) { const n = `${Math.abs(t)}`; const a = e - n.length; const r = t >= 0; return (r ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, a)).toString().substr(1) + n; } const z = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g; const V = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g; const H = {}; const E = {}; function B(t, e, i, n) { let a = n; typeof n === "string" && (a = function () { return this[n](); }), t && (E[t] = a), e && (E[e[0]] = function () { return N(a.apply(this, arguments), e[1], e[2]); }), i && (E[i] = function () { return this.localeData().ordinal(a.apply(this, arguments), t); }); } function j(t, e) { return t.isValid() ? (e = U(e, t.localeData()), H[e] = H[e] || (function (t) { let e; let i; let n; const a = t.match(z); for (e = 0, i = a.length; e < i; e++)E[a[e]] ? a[e] = E[a[e]] : a[e] = (n = a[e]).match(/\[[\s\S]/) ? n.replace(/^\[|\]$/g, "") : n.replace(/\\/g, ""); return function (e) { let n; let r = ""; for (n = 0; n < i; n++)r += T(a[n]) ? a[n].call(e, t) : a[n]; return r; }; }(e)), H[e](t)) : t.localeData().invalidDate(); } function U(t, e) { let i = 5; function n(t) { return e.longDateFormat(t) || t; } for (V.lastIndex = 0; i >= 0 && V.test(t);)t = t.replace(V, n), V.lastIndex = 0, i -= 1; return t; } const G = /\d/; const q = /\d\d/; const Z = /\d{3}/; const $ = /\d{4}/; const X = /[+-]?\d{6}/; const K = /\d\d?/; const J = /\d\d\d\d?/; const Q = /\d\d\d\d\d\d?/; const tt = /\d{1,3}/; const et = /\d{1,4}/; const it = /[+-]?\d{1,6}/; const nt = /\d+/; const at = /[+-]?\d+/; const rt = /Z|[+-]\d\d:?\d\d/gi; const ot = /Z|[+-]\d\d(?::?\d\d)?/gi; const st = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i; const lt = {}; function ut(t, e, i) { lt[t] = T(e) ? e : function (t, n) { return t && i ? i : e; }; } function dt(t, e) { return d(lt, t) ? lt[t](e._strict, e._locale) : new RegExp(ht(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (t, e, i, n, a) => e || i || n || a))); } function ht(t) { return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"); } const ct = {}; function ft(t, e) { let i; let n = e; for (typeof t === "string" && (t = [t]), s(e) && (n = function (t, i) { i[e] = k(t); }), i = 0; i < t.length; i++)ct[t[i]] = n; } function gt(t, e) { ft(t, (t, i, n, a) => { n._w = n._w || {}, e(t, n._w, n, a); }); } function mt(t, e, i) { e != null && d(ct, t) && ct[t](e, i._a, i, t); } const pt = 0; const vt = 1; const yt = 2; const bt = 3; const xt = 4; const _t = 5; const kt = 6; const wt = 7; const Mt = 8; function St(t) { return Dt(t) ? 366 : 365; } function Dt(t) { return t % 4 == 0 && t % 100 != 0 || t % 400 == 0; }B("Y", 0, 0, function () { const t = this.year(); return t <= 9999 ? `${t}` : `+${t}`; }), B(0, ["YY", 2], 0, function () { return this.year() % 100; }), B(0, ["YYYY", 4], 0, "year"), B(0, ["YYYYY", 5], 0, "year"), B(0, ["YYYYYY", 6, !0], 0, "year"), F("year", "y"), Y("year", 1), ut("Y", at), ut("YY", K, q), ut("YYYY", et, $), ut("YYYYY", it, X), ut("YYYYYY", it, X), ft(["YYYYY", "YYYYYY"], pt), ft("YYYY", (t, e) => { e[pt] = t.length === 2 ? n.parseTwoDigitYear(t) : k(t); }), ft("YY", (t, e) => { e[pt] = n.parseTwoDigitYear(t); }), ft("Y", (t, e) => { e[pt] = parseInt(t, 10); }), n.parseTwoDigitYear = function (t) { return k(t) + (k(t) > 68 ? 1900 : 2e3); }; let Ct; const Pt = Tt("FullYear", !0); function Tt(t, e) { return function (i) { return i != null ? (It(this, t, i), n.updateOffset(this, e), this) : Ot(this, t); }; } function Ot(t, e) { return t.isValid() ? t._d[`get${t._isUTC ? "UTC" : ""}${e}`]() : NaN; } function It(t, e, i) { t.isValid() && !isNaN(i) && (e === "FullYear" && Dt(t.year()) && t.month() === 1 && t.date() === 29 ? t._d[`set${t._isUTC ? "UTC" : ""}${e}`](i, t.month(), At(i, t.month())) : t._d[`set${t._isUTC ? "UTC" : ""}${e}`](i)); } function At(t, e) { if (isNaN(t) || isNaN(e)) return NaN; let i; const n = (e % (i = 12) + i) % i; return t += (e - n) / 12, n === 1 ? Dt(t) ? 29 : 28 : 31 - n % 7 % 2; }Ct = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) { let e; for (e = 0; e < this.length; ++e) if (this[e] === t) return e; return -1; }, B("M", ["MM", 2], "Mo", function () { return this.month() + 1; }), B("MMM", 0, 0, function (t) { return this.localeData().monthsShort(this, t); }), B("MMMM", 0, 0, function (t) { return this.localeData().months(this, t); }), F("month", "M"), Y("month", 8), ut("M", K), ut("MM", K, q), ut("MMM", (t, e) => e.monthsShortRegex(t)), ut("MMMM", (t, e) => e.monthsRegex(t)), ft(["M", "MM"], (t, e) => { e[vt] = k(t) - 1; }), ft(["MMM", "MMMM"], (t, e, i, n) => { const a = i._locale.monthsParse(t, n, i._strict); a != null ? e[vt] = a : f(i).invalidMonth = t; }); const Ft = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/; const Rt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"); const Lt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"); function Wt(t, e) { let i; if (!t.isValid()) return t; if (typeof e === "string") if (/^\d+$/.test(e))e = k(e); else if (!s(e = t.localeData().monthsParse(e))) return t; return i = Math.min(t.date(), At(t.year(), e)), t._d[`set${t._isUTC ? "UTC" : ""}Month`](e, i), t; } function Yt(t) { return t != null ? (Wt(this, t), n.updateOffset(this, !0), this) : Ot(this, "Month"); } const Nt = st; const zt = st; function Vt() { function t(t, e) { return e.length - t.length; } let e; let i; const n = []; const a = []; const r = []; for (e = 0; e < 12; e++)i = c([2e3, e]), n.push(this.monthsShort(i, "")), a.push(this.months(i, "")), r.push(this.months(i, "")), r.push(this.monthsShort(i, "")); for (n.sort(t), a.sort(t), r.sort(t), e = 0; e < 12; e++)n[e] = ht(n[e]), a[e] = ht(a[e]); for (e = 0; e < 24; e++)r[e] = ht(r[e]); this._monthsRegex = new RegExp(`^(${r.join("|")})`, "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(`^(${a.join("|")})`, "i"), this._monthsShortStrictRegex = new RegExp(`^(${n.join("|")})`, "i"); } function Ht(t) { let e; if (t < 100 && t >= 0) { const i = Array.prototype.slice.call(arguments); i[0] = t + 400, e = new Date(Date.UTC.apply(null, i)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t); } else e = new Date(Date.UTC.apply(null, arguments)); return e; } function Et(t, e, i) { const n = 7 + e - i; const a = (7 + Ht(t, 0, n).getUTCDay() - e) % 7; return -a + n - 1; } function Bt(t, e, i, n, a) { let r; let o; const s = (7 + i - n) % 7; const l = Et(t, n, a); const u = 1 + 7 * (e - 1) + s + l; return u <= 0 ? o = St(r = t - 1) + u : u > St(t) ? (r = t + 1, o = u - St(t)) : (r = t, o = u), { year: r, dayOfYear: o }; } function jt(t, e, i) { let n; let a; const r = Et(t.year(), e, i); const o = Math.floor((t.dayOfYear() - r - 1) / 7) + 1; return o < 1 ? (a = t.year() - 1, n = o + Ut(a, e, i)) : o > Ut(t.year(), e, i) ? (n = o - Ut(t.year(), e, i), a = t.year() + 1) : (a = t.year(), n = o), { week: n, year: a }; } function Ut(t, e, i) { const n = Et(t, e, i); const a = Et(t + 1, e, i); return (St(t) - n + a) / 7; } function Gt(t, e) { return t.slice(e, 7).concat(t.slice(0, e)); }B("w", ["ww", 2], "wo", "week"), B("W", ["WW", 2], "Wo", "isoWeek"), F("week", "w"), F("isoWeek", "W"), Y("week", 5), Y("isoWeek", 5), ut("w", K), ut("ww", K, q), ut("W", K), ut("WW", K, q), gt(["w", "ww", "W", "WW"], (t, e, i, n) => { e[n.substr(0, 1)] = k(t); }), B("d", 0, "do", "day"), B("dd", 0, 0, function (t) { return this.localeData().weekdaysMin(this, t); }), B("ddd", 0, 0, function (t) { return this.localeData().weekdaysShort(this, t); }), B("dddd", 0, 0, function (t) { return this.localeData().weekdays(this, t); }), B("e", 0, 0, "weekday"), B("E", 0, 0, "isoWeekday"), F("day", "d"), F("weekday", "e"), F("isoWeekday", "E"), Y("day", 11), Y("weekday", 11), Y("isoWeekday", 11), ut("d", K), ut("e", K), ut("E", K), ut("dd", (t, e) => e.weekdaysMinRegex(t)), ut("ddd", (t, e) => e.weekdaysShortRegex(t)), ut("dddd", (t, e) => e.weekdaysRegex(t)), gt(["dd", "ddd", "dddd"], (t, e, i, n) => { const a = i._locale.weekdaysParse(t, n, i._strict); a != null ? e.d = a : f(i).invalidWeekday = t; }), gt(["d", "e", "E"], (t, e, i, n) => { e[n] = k(t); }); const qt = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"); const Zt = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"); const $t = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"); const Xt = st; const Kt = st; const Jt = st; function Qt() { function t(t, e) { return e.length - t.length; } let e; let i; let n; let a; let r; const o = []; const s = []; const l = []; const u = []; for (e = 0; e < 7; e++)i = c([2e3, 1]).day(e), n = this.weekdaysMin(i, ""), a = this.weekdaysShort(i, ""), r = this.weekdays(i, ""), o.push(n), s.push(a), l.push(r), u.push(n), u.push(a), u.push(r); for (o.sort(t), s.sort(t), l.sort(t), u.sort(t), e = 0; e < 7; e++)s[e] = ht(s[e]), l[e] = ht(l[e]), u[e] = ht(u[e]); this._weekdaysRegex = new RegExp(`^(${u.join("|")})`, "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(`^(${l.join("|")})`, "i"), this._weekdaysShortStrictRegex = new RegExp(`^(${s.join("|")})`, "i"), this._weekdaysMinStrictRegex = new RegExp(`^(${o.join("|")})`, "i"); } function te() { return this.hours() % 12 || 12; } function ee(t, e) { B(t, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), e); }); } function ie(t, e) { return e._meridiemParse; }B("H", ["HH", 2], 0, "hour"), B("h", ["hh", 2], 0, te), B("k", ["kk", 2], 0, function () { return this.hours() || 24; }), B("hmm", 0, 0, function () { return `${te.apply(this)}${N(this.minutes(), 2)}`; }), B("hmmss", 0, 0, function () { return `${te.apply(this)}${N(this.minutes(), 2)}${N(this.seconds(), 2)}`; }), B("Hmm", 0, 0, function () { return `${this.hours()}${N(this.minutes(), 2)}`; }), B("Hmmss", 0, 0, function () { return `${this.hours()}${N(this.minutes(), 2)}${N(this.seconds(), 2)}`; }), ee("a", !0), ee("A", !1), F("hour", "h"), Y("hour", 13), ut("a", ie), ut("A", ie), ut("H", K), ut("h", K), ut("k", K), ut("HH", K, q), ut("hh", K, q), ut("kk", K, q), ut("hmm", J), ut("hmmss", Q), ut("Hmm", J), ut("Hmmss", Q), ft(["H", "HH"], bt), ft(["k", "kk"], (t, e, i) => { const n = k(t); e[bt] = n === 24 ? 0 : n; }), ft(["a", "A"], (t, e, i) => { i._isPm = i._locale.isPM(t), i._meridiem = t; }), ft(["h", "hh"], (t, e, i) => { e[bt] = k(t), f(i).bigHour = !0; }), ft("hmm", (t, e, i) => { const n = t.length - 2; e[bt] = k(t.substr(0, n)), e[xt] = k(t.substr(n)), f(i).bigHour = !0; }), ft("hmmss", (t, e, i) => { const n = t.length - 4; const a = t.length - 2; e[bt] = k(t.substr(0, n)), e[xt] = k(t.substr(n, 2)), e[_t] = k(t.substr(a)), f(i).bigHour = !0; }), ft("Hmm", (t, e, i) => { const n = t.length - 2; e[bt] = k(t.substr(0, n)), e[xt] = k(t.substr(n)); }), ft("Hmmss", (t, e, i) => { const n = t.length - 4; const a = t.length - 2; e[bt] = k(t.substr(0, n)), e[xt] = k(t.substr(n, 2)), e[_t] = k(t.substr(a)); }); let ne; const ae = Tt("Hours", !0); const re = {
                calendar: {
                    sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L",
                },
                longDateFormat: {
                    LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A",
                },
                invalidDate: "Invalid date",
                ordinal: "%d",
                dayOfMonthOrdinalParse: /\d{1,2}/,
                relativeTime: {
                    future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years",
                },
                months: Rt,
                monthsShort: Lt,
                week: { dow: 0, doy: 6 },
                weekdays: qt,
                weekdaysMin: $t,
                weekdaysShort: Zt,
                meridiemParse: /[ap]\.?m?\.?/i,
            }; const oe = {}; const se = {}; function le(t) { return t ? t.toLowerCase().replace("_", "-") : t; } function ue(e) { let i = null; if (!oe[e] && t && t.exports) try { i = ne._abbr; const n = _e; n(`./locale/${e}`), de(i); } catch (t) {} return oe[e]; } function de(t, e) { let i; return t && ((i = o(e) ? ce(t) : he(t, e)) ? ne = i : typeof console !== "undefined" && console.warn && console.warn(`Locale ${t} not found. Did you forget to load it?`)), ne._abbr; } function he(t, e) { if (e !== null) { let i; let n = re; if (e.abbr = t, oe[t] != null)P("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), n = oe[t]._config; else if (e.parentLocale != null) if (oe[e.parentLocale] != null)n = oe[e.parentLocale]._config; else { if ((i = ue(e.parentLocale)) == null) return se[e.parentLocale] || (se[e.parentLocale] = []), se[e.parentLocale].push({ name: t, config: e }), null; n = i._config; } return oe[t] = new I(O(n, e)), se[t] && se[t].forEach((t) => { he(t.name, t.config); }), de(t), oe[t]; } return delete oe[t], null; } function ce(t) { let e; if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return ne; if (!a(t)) { if (e = ue(t)) return e; t = [t]; } return (function (t) { for (var e, i, n, a, r = 0; r < t.length;) { for (a = le(t[r]).split("-"), e = a.length, i = (i = le(t[r + 1])) ? i.split("-") : null; e > 0;) { if (n = ue(a.slice(0, e).join("-"))) return n; if (i && i.length >= e && w(a, i, !0) >= e - 1) break; e--; }r++; } return ne; }(t)); } function fe(t) { let e; const i = t._a; return i && f(t).overflow === -2 && (e = i[vt] < 0 || i[vt] > 11 ? vt : i[yt] < 1 || i[yt] > At(i[pt], i[vt]) ? yt : i[bt] < 0 || i[bt] > 24 || i[bt] === 24 && (i[xt] !== 0 || i[_t] !== 0 || i[kt] !== 0) ? bt : i[xt] < 0 || i[xt] > 59 ? xt : i[_t] < 0 || i[_t] > 59 ? _t : i[kt] < 0 || i[kt] > 999 ? kt : -1, f(t)._overflowDayOfYear && (e < pt || e > yt) && (e = yt), f(t)._overflowWeeks && e === -1 && (e = wt), f(t)._overflowWeekday && e === -1 && (e = Mt), f(t).overflow = e), t; } function ge(t, e, i) { return t != null ? t : e != null ? e : i; } function me(t) { let e; let i; let a; let r; let o; const s = []; if (!t._d) { for (a = (function (t) { const e = new Date(n.now()); return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()]; }(t)), t._w && t._a[yt] == null && t._a[vt] == null && (function (t) { let e; let i; let n; let a; let r; let o; let s; let l; if ((e = t._w).GG != null || e.W != null || e.E != null)r = 1, o = 4, i = ge(e.GG, t._a[pt], jt(Ie(), 1, 4).year), n = ge(e.W, 1), ((a = ge(e.E, 1)) < 1 || a > 7) && (l = !0); else { r = t._locale._week.dow, o = t._locale._week.doy; const u = jt(Ie(), r, o); i = ge(e.gg, t._a[pt], u.year), n = ge(e.w, u.week), e.d != null ? ((a = e.d) < 0 || a > 6) && (l = !0) : e.e != null ? (a = e.e + r, (e.e < 0 || e.e > 6) && (l = !0)) : a = r; }n < 1 || n > Ut(i, r, o) ? f(t)._overflowWeeks = !0 : l != null ? f(t)._overflowWeekday = !0 : (s = Bt(i, n, a, r, o), t._a[pt] = s.year, t._dayOfYear = s.dayOfYear); }(t)), t._dayOfYear != null && (o = ge(t._a[pt], a[pt]), (t._dayOfYear > St(o) || t._dayOfYear === 0) && (f(t)._overflowDayOfYear = !0), i = Ht(o, 0, t._dayOfYear), t._a[vt] = i.getUTCMonth(), t._a[yt] = i.getUTCDate()), e = 0; e < 3 && t._a[e] == null; ++e)t._a[e] = s[e] = a[e]; for (;e < 7; e++)t._a[e] = s[e] = t._a[e] == null ? e === 2 ? 1 : 0 : t._a[e]; t._a[bt] === 24 && t._a[xt] === 0 && t._a[_t] === 0 && t._a[kt] === 0 && (t._nextDay = !0, t._a[bt] = 0), t._d = (t._useUTC ? Ht : function (t, e, i, n, a, r, o) { let s; return t < 100 && t >= 0 ? (s = new Date(t + 400, e, i, n, a, r, o), isFinite(s.getFullYear()) && s.setFullYear(t)) : s = new Date(t, e, i, n, a, r, o), s; }).apply(null, s), r = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), t._tzm != null && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[bt] = 24), t._w && void 0 !== t._w.d && t._w.d !== r && (f(t).weekdayMismatch = !0); } } const pe = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/; const ve = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/; const ye = /Z|[+-]\d\d(?::?\d\d)?/; const be = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]]; const xe = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]]; const ke = /^\/?Date\((\-?\d+)/i; function we(t) { let e; let i; let n; let a; let r; let o; const s = t._i; const l = pe.exec(s) || ve.exec(s); if (l) { for (f(t).iso = !0, e = 0, i = be.length; e < i; e++) if (be[e][1].exec(l[1])) { a = be[e][0], n = !1 !== be[e][2]; break; } if (a == null) return void (t._isValid = !1); if (l[3]) { for (e = 0, i = xe.length; e < i; e++) if (xe[e][1].exec(l[3])) { r = (l[2] || " ") + xe[e][0]; break; } if (r == null) return void (t._isValid = !1); } if (!n && r != null) return void (t._isValid = !1); if (l[4]) { if (!ye.exec(l[4])) return void (t._isValid = !1); o = "Z"; }t._f = a + (r || "") + (o || ""), Pe(t); } else t._isValid = !1; } const Me = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/; function Se(t) { const e = parseInt(t, 10); return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e; } const De = {
                UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480,
            }; function Ce(t) { let e; let i; let n; let a; let r; let o; let s; const l = Me.exec(t._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")); if (l) { const u = (e = l[4], i = l[3], n = l[2], a = l[5], r = l[6], o = l[7], s = [Se(e), Lt.indexOf(i), parseInt(n, 10), parseInt(a, 10), parseInt(r, 10)], o && s.push(parseInt(o, 10)), s); if (!(function (t, e, i) { if (t) { const n = Zt.indexOf(t); const a = new Date(e[0], e[1], e[2]).getDay(); if (n !== a) return f(i).weekdayMismatch = !0, i._isValid = !1, !1; } return !0; }(l[1], u, t))) return; t._a = u, t._tzm = (function (t, e, i) { if (t) return De[t]; if (e) return 0; const n = parseInt(i, 10); const a = n % 100; const r = (n - a) / 100; return 60 * r + a; }(l[8], l[9], l[10])), t._d = Ht.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), f(t).rfc2822 = !0; } else t._isValid = !1; } function Pe(t) { if (t._f !== n.ISO_8601) if (t._f !== n.RFC_2822) { t._a = [], f(t).empty = !0; let e; let i; let a; let r; let o; let s = `${t._i}`; const l = s.length; let u = 0; for (a = U(t._f, t._locale).match(z) || [], e = 0; e < a.length; e++)r = a[e], (i = (s.match(dt(r, t)) || [])[0]) && ((o = s.substr(0, s.indexOf(i))).length > 0 && f(t).unusedInput.push(o), s = s.slice(s.indexOf(i) + i.length), u += i.length), E[r] ? (i ? f(t).empty = !1 : f(t).unusedTokens.push(r), mt(r, i, t)) : t._strict && !i && f(t).unusedTokens.push(r); f(t).charsLeftOver = l - u, s.length > 0 && f(t).unusedInput.push(s), t._a[bt] <= 12 && !0 === f(t).bigHour && t._a[bt] > 0 && (f(t).bigHour = void 0), f(t).parsedDateParts = t._a.slice(0), f(t).meridiem = t._meridiem, t._a[bt] = (d = t._locale, h = t._a[bt], (c = t._meridiem) == null ? h : d.meridiemHour != null ? d.meridiemHour(h, c) : d.isPM != null ? ((g = d.isPM(c)) && h < 12 && (h += 12), g || h !== 12 || (h = 0), h) : h), me(t), fe(t); } else Ce(t); else we(t); let d; let h; let c; let g; } function Te(t) { let e = t._i; const i = t._f; return t._locale = t._locale || ce(t._l), e === null || void 0 === i && e === "" ? m({ nullInput: !0 }) : (typeof e === "string" && (t._i = e = t._locale.preparse(e)), x(e) ? new b(fe(e)) : (l(e) ? t._d = e : a(i) ? (function (t) { let e; let i; let n; let a; let r; if (t._f.length === 0) return f(t).invalidFormat = !0, void (t._d = new Date(NaN)); for (a = 0; a < t._f.length; a++)r = 0, e = v({}, t), t._useUTC != null && (e._useUTC = t._useUTC), e._f = t._f[a], Pe(e), g(e) && (r += f(e).charsLeftOver, r += 10 * f(e).unusedTokens.length, f(e).score = r, (n == null || r < n) && (n = r, i = e)); h(t, i || e); }(t)) : i ? Pe(t) : (function (t) { const e = t._i; o(e) ? t._d = new Date(n.now()) : l(e) ? t._d = new Date(e.valueOf()) : typeof e === "string" ? (function (t) { const e = ke.exec(t._i); e === null ? (we(t), !1 === t._isValid && (delete t._isValid, Ce(t), !1 === t._isValid && (delete t._isValid, n.createFromInputFallback(t)))) : t._d = new Date(+e[1]); }(t)) : a(e) ? (t._a = u(e.slice(0), (t) => parseInt(t, 10)), me(t)) : r(e) ? (function (t) { if (!t._d) { const e = L(t._i); t._a = u([e.year, e.month, e.day || e.date, e.hour, e.minute, e.second, e.millisecond], (t) => t && parseInt(t, 10)), me(t); } }(t)) : s(e) ? t._d = new Date(e) : n.createFromInputFallback(t); }(t)), g(t) || (t._d = null), t)); } function Oe(t, e, i, n, o) { let s; const l = {}; return !0 !== i && !1 !== i || (n = i, i = void 0), (r(t) && (function (t) { if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(t).length === 0; let e; for (e in t) if (t.hasOwnProperty(e)) return !1; return !0; }(t)) || a(t) && t.length === 0) && (t = void 0), l._isAMomentObject = !0, l._useUTC = l._isUTC = o, l._l = i, l._i = t, l._f = e, l._strict = n, (s = new b(fe(Te(l))))._nextDay && (s.add(1, "d"), s._nextDay = void 0), s; } function Ie(t, e, i, n) { return Oe(t, e, i, n, !1); }n.createFromInputFallback = S("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (t) => { t._d = new Date(t._i + (t._useUTC ? " UTC" : "")); }), n.ISO_8601 = function () {}, n.RFC_2822 = function () {}; const Ae = S("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () { const t = Ie.apply(null, arguments); return this.isValid() && t.isValid() ? t < this ? this : t : m(); }); const Fe = S("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () { const t = Ie.apply(null, arguments); return this.isValid() && t.isValid() ? t > this ? this : t : m(); }); function Re(t, e) { let i; let n; if (e.length === 1 && a(e[0]) && (e = e[0]), !e.length) return Ie(); for (i = e[0], n = 1; n < e.length; ++n)e[n].isValid() && !e[n][t](i) || (i = e[n]); return i; } const Le = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"]; function We(t) { const e = L(t); const i = e.year || 0; const n = e.quarter || 0; const a = e.month || 0; const r = e.week || e.isoWeek || 0; const o = e.day || 0; const s = e.hour || 0; const l = e.minute || 0; const u = e.second || 0; const d = e.millisecond || 0; this._isValid = (function (t) { for (const e in t) if (Ct.call(Le, e) === -1 || t[e] != null && isNaN(t[e])) return !1; for (let i = !1, n = 0; n < Le.length; ++n) if (t[Le[n]]) { if (i) return !1; parseFloat(t[Le[n]]) !== k(t[Le[n]]) && (i = !0); } return !0; }(e)), this._milliseconds = +d + 1e3 * u + 6e4 * l + 1e3 * s * 60 * 60, this._days = +o + 7 * r, this._months = +a + 3 * n + 12 * i, this._data = {}, this._locale = ce(), this._bubble(); } function Ye(t) { return t instanceof We; } function Ne(t) { return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t); } function ze(t, e) { B(t, 0, 0, function () { let t = this.utcOffset(); let i = "+"; return t < 0 && (t = -t, i = "-"), i + N(~~(t / 60), 2) + e + N(~~t % 60, 2); }); }ze("Z", ":"), ze("ZZ", ""), ut("Z", ot), ut("ZZ", ot), ft(["Z", "ZZ"], (t, e, i) => { i._useUTC = !0, i._tzm = He(ot, t); }); const Ve = /([\+\-]|\d\d)/gi; function He(t, e) { const i = (e || "").match(t); if (i === null) return null; const n = i[i.length - 1] || []; const a = (`${n}`).match(Ve) || ["-", 0, 0]; const r = 60 * a[1] + k(a[2]); return r === 0 ? 0 : a[0] === "+" ? r : -r; } function Ee(t, e) { let i; let a; return e._isUTC ? (i = e.clone(), a = (x(t) || l(t) ? t.valueOf() : Ie(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + a), n.updateOffset(i, !1), i) : Ie(t).local(); } function Be(t) { return 15 * -Math.round(t._d.getTimezoneOffset() / 15); } function je() { return !!this.isValid() && this._isUTC && this._offset === 0; }n.updateOffset = function () {}; const Ue = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; const Ge = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/; function qe(t, e) {
                let i; let n; let a; let r; let o; let l; let u = t; let h = null; return Ye(t) ? u = { ms: t._milliseconds, d: t._days, M: t._months } : s(t) ? (u = {}, e ? u[e] = t : u.milliseconds = t) : (h = Ue.exec(t)) ? (i = h[1] === "-" ? -1 : 1, u = {
                    y: 0, d: k(h[yt]) * i, h: k(h[bt]) * i, m: k(h[xt]) * i, s: k(h[_t]) * i, ms: k(Ne(1e3 * h[kt])) * i,
                }) : (h = Ge.exec(t)) ? (i = h[1] === "-" ? -1 : 1, u = {
                    y: Ze(h[2], i), M: Ze(h[3], i), w: Ze(h[4], i), d: Ze(h[5], i), h: Ze(h[6], i), m: Ze(h[7], i), s: Ze(h[8], i),
                }) : u == null ? u = {} : typeof u === "object" && ("from" in u || "to" in u) && (r = Ie(u.from), o = Ie(u.to), a = r.isValid() && o.isValid() ? (o = Ee(o, r), r.isBefore(o) ? l = $e(r, o) : ((l = $e(o, r)).milliseconds = -l.milliseconds, l.months = -l.months), l) : { milliseconds: 0, months: 0 }, (u = {}).ms = a.milliseconds, u.M = a.months), n = new We(u), Ye(t) && d(t, "_locale") && (n._locale = t._locale), n;
            } function Ze(t, e) { const i = t && parseFloat(t.replace(",", ".")); return (isNaN(i) ? 0 : i) * e; } function $e(t, e) { const i = {}; return i.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i; } function Xe(t, e) { return function (i, n) { let a; return n === null || isNaN(+n) || (P(e, `moment().${e}(period, number) is deprecated. Please use moment().${e}(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.`), a = i, i = n, n = a), Ke(this, qe(i = typeof i === "string" ? +i : i, n), t), this; }; } function Ke(t, e, i, a) { const r = e._milliseconds; const o = Ne(e._days); const s = Ne(e._months); t.isValid() && (a = a == null || a, s && Wt(t, Ot(t, "Month") + s * i), o && It(t, "Date", Ot(t, "Date") + o * i), r && t._d.setTime(t._d.valueOf() + r * i), a && n.updateOffset(t, o || s)); }qe.fn = We.prototype, qe.invalid = function () { return qe(NaN); }; const Je = Xe(1, "add"); const Qe = Xe(-1, "subtract"); function ti(t, e) { let i; let n; const a = 12 * (e.year() - t.year()) + (e.month() - t.month()); const r = t.clone().add(a, "months"); return e - r < 0 ? (i = t.clone().add(a - 1, "months"), n = (e - r) / (r - i)) : (i = t.clone().add(a + 1, "months"), n = (e - r) / (i - r)), -(a + n) || 0; } function ei(t) { let e; return void 0 === t ? this._locale._abbr : ((e = ce(t)) != null && (this._locale = e), this); }n.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", n.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]"; const ii = S("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (t) { return void 0 === t ? this.localeData() : this.locale(t); }); function ni() { return this._locale; } const ai = 1e3; const ri = 60 * ai; const oi = 60 * ri; const si = 3506328 * oi; function li(t, e) { return (t % e + e) % e; } function ui(t, e, i) { return t < 100 && t >= 0 ? new Date(t + 400, e, i) - si : new Date(t, e, i).valueOf(); } function di(t, e, i) { return t < 100 && t >= 0 ? Date.UTC(t + 400, e, i) - si : Date.UTC(t, e, i); } function hi(t, e) { B(0, [t, t.length], 0, e); } function ci(t, e, i, n, a) { let r; return t == null ? jt(this, n, a).year : (r = Ut(t, n, a), e > r && (e = r), function (t, e, i, n, a) { const r = Bt(t, e, i, n, a); const o = Ht(r.year, 0, r.dayOfYear); return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this; }.call(this, t, e, i, n, a)); }B(0, ["gg", 2], 0, function () { return this.weekYear() % 100; }), B(0, ["GG", 2], 0, function () { return this.isoWeekYear() % 100; }), hi("gggg", "weekYear"), hi("ggggg", "weekYear"), hi("GGGG", "isoWeekYear"), hi("GGGGG", "isoWeekYear"), F("weekYear", "gg"), F("isoWeekYear", "GG"), Y("weekYear", 1), Y("isoWeekYear", 1), ut("G", at), ut("g", at), ut("GG", K, q), ut("gg", K, q), ut("GGGG", et, $), ut("gggg", et, $), ut("GGGGG", it, X), ut("ggggg", it, X), gt(["gggg", "ggggg", "GGGG", "GGGGG"], (t, e, i, n) => { e[n.substr(0, 2)] = k(t); }), gt(["gg", "GG"], (t, e, i, a) => { e[a] = n.parseTwoDigitYear(t); }), B("Q", 0, "Qo", "quarter"), F("quarter", "Q"), Y("quarter", 7), ut("Q", G), ft("Q", (t, e) => { e[vt] = 3 * (k(t) - 1); }), B("D", ["DD", 2], "Do", "date"), F("date", "D"), Y("date", 9), ut("D", K), ut("DD", K, q), ut("Do", (t, e) => (t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient)), ft(["D", "DD"], yt), ft("Do", (t, e) => { e[yt] = k(t.match(K)[0]); }); const fi = Tt("Date", !0); B("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), F("dayOfYear", "DDD"), Y("dayOfYear", 4), ut("DDD", tt), ut("DDDD", Z), ft(["DDD", "DDDD"], (t, e, i) => { i._dayOfYear = k(t); }), B("m", ["mm", 2], 0, "minute"), F("minute", "m"), Y("minute", 14), ut("m", K), ut("mm", K, q), ft(["m", "mm"], xt); const gi = Tt("Minutes", !1); B("s", ["ss", 2], 0, "second"), F("second", "s"), Y("second", 15), ut("s", K), ut("ss", K, q), ft(["s", "ss"], _t); let mi; const pi = Tt("Seconds", !1); for (B("S", 0, 0, function () { return ~~(this.millisecond() / 100); }), B(0, ["SS", 2], 0, function () { return ~~(this.millisecond() / 10); }), B(0, ["SSS", 3], 0, "millisecond"), B(0, ["SSSS", 4], 0, function () { return 10 * this.millisecond(); }), B(0, ["SSSSS", 5], 0, function () { return 100 * this.millisecond(); }), B(0, ["SSSSSS", 6], 0, function () { return 1e3 * this.millisecond(); }), B(0, ["SSSSSSS", 7], 0, function () { return 1e4 * this.millisecond(); }), B(0, ["SSSSSSSS", 8], 0, function () { return 1e5 * this.millisecond(); }), B(0, ["SSSSSSSSS", 9], 0, function () { return 1e6 * this.millisecond(); }), F("millisecond", "ms"), Y("millisecond", 16), ut("S", tt, G), ut("SS", tt, q), ut("SSS", tt, Z), mi = "SSSS"; mi.length <= 9; mi += "S")ut(mi, nt); function vi(t, e) { e[kt] = k(1e3 * (`0.${t}`)); } for (mi = "S"; mi.length <= 9; mi += "S")ft(mi, vi); const yi = Tt("Milliseconds", !1); B("z", 0, 0, "zoneAbbr"), B("zz", 0, 0, "zoneName"); const bi = b.prototype; function xi(t) { return t; }bi.add = Je, bi.calendar = function (t, e) { const i = t || Ie(); const a = Ee(i, this).startOf("day"); const r = n.calendarFormat(this, a) || "sameElse"; const o = e && (T(e[r]) ? e[r].call(this, i) : e[r]); return this.format(o || this.localeData().calendar(r, this, Ie(i))); }, bi.clone = function () { return new b(this); }, bi.diff = function (t, e, i) { let n; let a; let r; if (!this.isValid()) return NaN; if (!(n = Ee(t, this)).isValid()) return NaN; switch (a = 6e4 * (n.utcOffset() - this.utcOffset()), e = R(e)) { case "year": r = ti(this, n) / 12; break; case "month": r = ti(this, n); break; case "quarter": r = ti(this, n) / 3; break; case "second": r = (this - n) / 1e3; break; case "minute": r = (this - n) / 6e4; break; case "hour": r = (this - n) / 36e5; break; case "day": r = (this - n - a) / 864e5; break; case "week": r = (this - n - a) / 6048e5; break; default: r = this - n; } return i ? r : _(r); }, bi.endOf = function (t) { let e; if (void 0 === (t = R(t)) || t === "millisecond" || !this.isValid()) return this; const i = this._isUTC ? di : ui; switch (t) { case "year": e = i(this.year() + 1, 0, 1) - 1; break; case "quarter": e = i(this.year(), this.month() - this.month() % 3 + 3, 1) - 1; break; case "month": e = i(this.year(), this.month() + 1, 1) - 1; break; case "week": e = i(this.year(), this.month(), this.date() - this.weekday() + 7) - 1; break; case "isoWeek": e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1; break; case "day": case "date": e = i(this.year(), this.month(), this.date() + 1) - 1; break; case "hour": e = this._d.valueOf(), e += oi - li(e + (this._isUTC ? 0 : this.utcOffset() * ri), oi) - 1; break; case "minute": e = this._d.valueOf(), e += ri - li(e, ri) - 1; break; case "second": e = this._d.valueOf(), e += ai - li(e, ai) - 1; } return this._d.setTime(e), n.updateOffset(this, !0), this; }, bi.format = function (t) { t || (t = this.isUtc() ? n.defaultFormatUtc : n.defaultFormat); const e = j(this, t); return this.localeData().postformat(e); }, bi.from = function (t, e) { return this.isValid() && (x(t) && t.isValid() || Ie(t).isValid()) ? qe({ to: this, from: t }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate(); }, bi.fromNow = function (t) { return this.from(Ie(), t); }, bi.to = function (t, e) { return this.isValid() && (x(t) && t.isValid() || Ie(t).isValid()) ? qe({ from: this, to: t }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate(); }, bi.toNow = function (t) { return this.to(Ie(), t); }, bi.get = function (t) { return T(this[t = R(t)]) ? this[t]() : this; }, bi.invalidAt = function () { return f(this).overflow; }, bi.isAfter = function (t, e) { const i = x(t) ? t : Ie(t); return !(!this.isValid() || !i.isValid()) && ((e = R(e) || "millisecond") === "millisecond" ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf()); }, bi.isBefore = function (t, e) { const i = x(t) ? t : Ie(t); return !(!this.isValid() || !i.isValid()) && ((e = R(e) || "millisecond") === "millisecond" ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf()); }, bi.isBetween = function (t, e, i, n) { const a = x(t) ? t : Ie(t); const r = x(e) ? e : Ie(e); return !!(this.isValid() && a.isValid() && r.isValid()) && (((n = n || "()")[0] === "(" ? this.isAfter(a, i) : !this.isBefore(a, i)) && (n[1] === ")" ? this.isBefore(r, i) : !this.isAfter(r, i))); }, bi.isSame = function (t, e) { let i; const n = x(t) ? t : Ie(t); return !(!this.isValid() || !n.isValid()) && ((e = R(e) || "millisecond") === "millisecond" ? this.valueOf() === n.valueOf() : (i = n.valueOf(), this.clone().startOf(e).valueOf() <= i && i <= this.clone().endOf(e).valueOf())); }, bi.isSameOrAfter = function (t, e) { return this.isSame(t, e) || this.isAfter(t, e); }, bi.isSameOrBefore = function (t, e) { return this.isSame(t, e) || this.isBefore(t, e); }, bi.isValid = function () { return g(this); }, bi.lang = ii, bi.locale = ei, bi.localeData = ni, bi.max = Fe, bi.min = Ae, bi.parsingFlags = function () { return h({}, f(this)); }, bi.set = function (t, e) { if (typeof t === "object") for (let i = (function (t) { const e = []; for (const i in t)e.push({ unit: i, priority: W[i] }); return e.sort((t, e) => t.priority - e.priority), e; }(t = L(t))), n = 0; n < i.length; n++) this[i[n].unit](t[i[n].unit]); else if (T(this[t = R(t)])) return this[t](e); return this; }, bi.startOf = function (t) { let e; if (void 0 === (t = R(t)) || t === "millisecond" || !this.isValid()) return this; const i = this._isUTC ? di : ui; switch (t) { case "year": e = i(this.year(), 0, 1); break; case "quarter": e = i(this.year(), this.month() - this.month() % 3, 1); break; case "month": e = i(this.year(), this.month(), 1); break; case "week": e = i(this.year(), this.month(), this.date() - this.weekday()); break; case "isoWeek": e = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1)); break; case "day": case "date": e = i(this.year(), this.month(), this.date()); break; case "hour": e = this._d.valueOf(), e -= li(e + (this._isUTC ? 0 : this.utcOffset() * ri), oi); break; case "minute": e = this._d.valueOf(), e -= li(e, ri); break; case "second": e = this._d.valueOf(), e -= li(e, ai); } return this._d.setTime(e), n.updateOffset(this, !0), this; }, bi.subtract = Qe, bi.toArray = function () { const t = this; return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]; }, bi.toObject = function () {
                const t = this; return {
                    years: t.year(), months: t.month(), date: t.date(), hours: t.hours(), minutes: t.minutes(), seconds: t.seconds(), milliseconds: t.milliseconds(),
                };
            }, bi.toDate = function () { return new Date(this.valueOf()); }, bi.toISOString = function (t) { if (!this.isValid()) return null; const e = !0 !== t; const i = e ? this.clone().utc() : this; return i.year() < 0 || i.year() > 9999 ? j(i, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : T(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", j(i, "Z")) : j(i, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"); }, bi.inspect = function () { if (!this.isValid()) return `moment.invalid(/* ${this._i} */)`; let t = "moment"; let e = ""; this.isLocal() || (t = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"); const i = `[${t}("]`; const n = this.year() >= 0 && this.year() <= 9999 ? "YYYY" : "YYYYYY"; const a = `${e}[")]`; return this.format(`${i + n}-MM-DD[T]HH:mm:ss.SSS${a}`); }, bi.toJSON = function () { return this.isValid() ? this.toISOString() : null; }, bi.toString = function () { return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ"); }, bi.unix = function () { return Math.floor(this.valueOf() / 1e3); }, bi.valueOf = function () { return this._d.valueOf() - 6e4 * (this._offset || 0); }, bi.creationData = function () {
                return {
                    input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict,
                };
            }, bi.year = Pt, bi.isLeapYear = function () { return Dt(this.year()); }, bi.weekYear = function (t) { return ci.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy); }, bi.isoWeekYear = function (t) { return ci.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4); }, bi.quarter = bi.quarters = function (t) { return t == null ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3); }, bi.month = Yt, bi.daysInMonth = function () { return At(this.year(), this.month()); }, bi.week = bi.weeks = function (t) { const e = this.localeData().week(this); return t == null ? e : this.add(7 * (t - e), "d"); }, bi.isoWeek = bi.isoWeeks = function (t) { const e = jt(this, 1, 4).week; return t == null ? e : this.add(7 * (t - e), "d"); }, bi.weeksInYear = function () { const t = this.localeData()._week; return Ut(this.year(), t.dow, t.doy); }, bi.isoWeeksInYear = function () { return Ut(this.year(), 1, 4); }, bi.date = fi, bi.day = bi.days = function (t) { if (!this.isValid()) return t != null ? this : NaN; const e = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return t != null ? (t = (function (t, e) { return typeof t !== "string" ? t : isNaN(t) ? typeof (t = e.weekdaysParse(t)) === "number" ? t : null : parseInt(t, 10); }(t, this.localeData())), this.add(t - e, "d")) : e; }, bi.weekday = function (t) { if (!this.isValid()) return t != null ? this : NaN; const e = (this.day() + 7 - this.localeData()._week.dow) % 7; return t == null ? e : this.add(t - e, "d"); }, bi.isoWeekday = function (t) { if (!this.isValid()) return t != null ? this : NaN; if (t != null) { const e = (function (t, e) { return typeof t === "string" ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t; }(t, this.localeData())); return this.day(this.day() % 7 ? e : e - 7); } return this.day() || 7; }, bi.dayOfYear = function (t) { const e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1; return t == null ? e : this.add(t - e, "d"); }, bi.hour = bi.hours = ae, bi.minute = bi.minutes = gi, bi.second = bi.seconds = pi, bi.millisecond = bi.milliseconds = yi, bi.utcOffset = function (t, e, i) { let a; const r = this._offset || 0; if (!this.isValid()) return t != null ? this : NaN; if (t != null) { if (typeof t === "string") { if ((t = He(ot, t)) === null) return this; } else Math.abs(t) < 16 && !i && (t *= 60); return !this._isUTC && e && (a = Be(this)), this._offset = t, this._isUTC = !0, a != null && this.add(a, "m"), r !== t && (!e || this._changeInProgress ? Ke(this, qe(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, n.updateOffset(this, !0), this._changeInProgress = null)), this; } return this._isUTC ? r : Be(this); }, bi.utc = function (t) { return this.utcOffset(0, t); }, bi.local = function (t) { return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(Be(this), "m")), this; }, bi.parseZone = function () { if (this._tzm != null) this.utcOffset(this._tzm, !1, !0); else if (typeof this._i === "string") { const t = He(rt, this._i); t != null ? this.utcOffset(t) : this.utcOffset(0, !0); } return this; }, bi.hasAlignedHourOffset = function (t) { return !!this.isValid() && (t = t ? Ie(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0); }, bi.isDST = function () { return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset(); }, bi.isLocal = function () { return !!this.isValid() && !this._isUTC; }, bi.isUtcOffset = function () { return !!this.isValid() && this._isUTC; }, bi.isUtc = je, bi.isUTC = je, bi.zoneAbbr = function () { return this._isUTC ? "UTC" : ""; }, bi.zoneName = function () { return this._isUTC ? "Coordinated Universal Time" : ""; }, bi.dates = S("dates accessor is deprecated. Use date instead.", fi), bi.months = S("months accessor is deprecated. Use month instead", Yt), bi.years = S("years accessor is deprecated. Use year instead", Pt), bi.zone = S("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (t, e) { return t != null ? (typeof t !== "string" && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset(); }), bi.isDSTShifted = S("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () { if (!o(this._isDSTShifted)) return this._isDSTShifted; let t = {}; if (v(t, this), (t = Te(t))._a) { const e = t._isUTC ? c(t._a) : Ie(t._a); this._isDSTShifted = this.isValid() && w(t._a, e.toArray()) > 0; } else this._isDSTShifted = !1; return this._isDSTShifted; }); const _i = I.prototype; function ki(t, e, i, n) { const a = ce(); const r = c().set(n, e); return a[i](r, t); } function wi(t, e, i) { if (s(t) && (e = t, t = void 0), t = t || "", e != null) return ki(t, e, i, "month"); let n; const a = []; for (n = 0; n < 12; n++)a[n] = ki(t, n, i, "month"); return a; } function Mi(t, e, i, n) { typeof t === "boolean" ? (s(e) && (i = e, e = void 0), e = e || "") : (i = e = t, t = !1, s(e) && (i = e, e = void 0), e = e || ""); let a; const r = ce(); const o = t ? r._week.dow : 0; if (i != null) return ki(e, (i + o) % 7, n, "day"); const l = []; for (a = 0; a < 7; a++)l[a] = ki(e, (a + o) % 7, n, "day"); return l; }_i.calendar = function (t, e, i) { const n = this._calendar[t] || this._calendar.sameElse; return T(n) ? n.call(e, i) : n; }, _i.longDateFormat = function (t) { const e = this._longDateFormat[t]; const i = this._longDateFormat[t.toUpperCase()]; return e || !i ? e : (this._longDateFormat[t] = i.replace(/MMMM|MM|DD|dddd/g, (t) => t.slice(1)), this._longDateFormat[t]); }, _i.invalidDate = function () { return this._invalidDate; }, _i.ordinal = function (t) { return this._ordinal.replace("%d", t); }, _i.preparse = xi, _i.postformat = xi, _i.relativeTime = function (t, e, i, n) { const a = this._relativeTime[i]; return T(a) ? a(t, e, i, n) : a.replace(/%d/i, t); }, _i.pastFuture = function (t, e) { const i = this._relativeTime[t > 0 ? "future" : "past"]; return T(i) ? i(e) : i.replace(/%s/i, e); }, _i.set = function (t) { let e; let i; for (i in t)T(e = t[i]) ? this[i] = e : this[`_${i}`] = e; this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp(`${this._dayOfMonthOrdinalParse.source || this._ordinalParse.source}|${/\d{1,2}/.source}`); }, _i.months = function (t, e) { return t ? a(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || Ft).test(e) ? "format" : "standalone"][t.month()] : a(this._months) ? this._months : this._months.standalone; }, _i.monthsShort = function (t, e) { return t ? a(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[Ft.test(e) ? "format" : "standalone"][t.month()] : a(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone; }, _i.monthsParse = function (t, e, i) { let n; let a; let r; if (this._monthsParseExact) return function (t, e, i) { let n; let a; let r; const o = t.toLocaleLowerCase(); if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n)r = c([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[n] = this.months(r, "").toLocaleLowerCase(); return i ? e === "MMM" ? (a = Ct.call(this._shortMonthsParse, o)) !== -1 ? a : null : (a = Ct.call(this._longMonthsParse, o)) !== -1 ? a : null : e === "MMM" ? (a = Ct.call(this._shortMonthsParse, o)) !== -1 ? a : (a = Ct.call(this._longMonthsParse, o)) !== -1 ? a : null : (a = Ct.call(this._longMonthsParse, o)) !== -1 ? a : (a = Ct.call(this._shortMonthsParse, o)) !== -1 ? a : null; }.call(this, t, e, i); for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) { if (a = c([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp(`^${this.months(a, "").replace(".", "")}$`, "i"), this._shortMonthsParse[n] = new RegExp(`^${this.monthsShort(a, "").replace(".", "")}$`, "i")), i || this._monthsParse[n] || (r = `^${this.months(a, "")}|^${this.monthsShort(a, "")}`, this._monthsParse[n] = new RegExp(r.replace(".", ""), "i")), i && e === "MMMM" && this._longMonthsParse[n].test(t)) return n; if (i && e === "MMM" && this._shortMonthsParse[n].test(t)) return n; if (!i && this._monthsParse[n].test(t)) return n; } }, _i.monthsRegex = function (t) { return this._monthsParseExact ? (d(this, "_monthsRegex") || Vt.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (d(this, "_monthsRegex") || (this._monthsRegex = zt), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex); }, _i.monthsShortRegex = function (t) { return this._monthsParseExact ? (d(this, "_monthsRegex") || Vt.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (d(this, "_monthsShortRegex") || (this._monthsShortRegex = Nt), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex); }, _i.week = function (t) { return jt(t, this._week.dow, this._week.doy).week; }, _i.firstDayOfYear = function () { return this._week.doy; }, _i.firstDayOfWeek = function () { return this._week.dow; }, _i.weekdays = function (t, e) { const i = a(this._weekdays) ? this._weekdays : this._weekdays[t && !0 !== t && this._weekdays.isFormat.test(e) ? "format" : "standalone"]; return !0 === t ? Gt(i, this._week.dow) : t ? i[t.day()] : i; }, _i.weekdaysMin = function (t) { return !0 === t ? Gt(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin; }, _i.weekdaysShort = function (t) { return !0 === t ? Gt(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort; }, _i.weekdaysParse = function (t, e, i) { let n; let a; let r; if (this._weekdaysParseExact) return function (t, e, i) { let n; let a; let r; const o = t.toLocaleLowerCase(); if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n)r = c([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(r, "").toLocaleLowerCase(); return i ? e === "dddd" ? (a = Ct.call(this._weekdaysParse, o)) !== -1 ? a : null : e === "ddd" ? (a = Ct.call(this._shortWeekdaysParse, o)) !== -1 ? a : null : (a = Ct.call(this._minWeekdaysParse, o)) !== -1 ? a : null : e === "dddd" ? (a = Ct.call(this._weekdaysParse, o)) !== -1 ? a : (a = Ct.call(this._shortWeekdaysParse, o)) !== -1 ? a : (a = Ct.call(this._minWeekdaysParse, o)) !== -1 ? a : null : e === "ddd" ? (a = Ct.call(this._shortWeekdaysParse, o)) !== -1 ? a : (a = Ct.call(this._weekdaysParse, o)) !== -1 ? a : (a = Ct.call(this._minWeekdaysParse, o)) !== -1 ? a : null : (a = Ct.call(this._minWeekdaysParse, o)) !== -1 ? a : (a = Ct.call(this._weekdaysParse, o)) !== -1 ? a : (a = Ct.call(this._shortWeekdaysParse, o)) !== -1 ? a : null; }.call(this, t, e, i); for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) { if (a = c([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp(`^${this.weekdays(a, "").replace(".", "\\.?")}$`, "i"), this._shortWeekdaysParse[n] = new RegExp(`^${this.weekdaysShort(a, "").replace(".", "\\.?")}$`, "i"), this._minWeekdaysParse[n] = new RegExp(`^${this.weekdaysMin(a, "").replace(".", "\\.?")}$`, "i")), this._weekdaysParse[n] || (r = `^${this.weekdays(a, "")}|^${this.weekdaysShort(a, "")}|^${this.weekdaysMin(a, "")}`, this._weekdaysParse[n] = new RegExp(r.replace(".", ""), "i")), i && e === "dddd" && this._fullWeekdaysParse[n].test(t)) return n; if (i && e === "ddd" && this._shortWeekdaysParse[n].test(t)) return n; if (i && e === "dd" && this._minWeekdaysParse[n].test(t)) return n; if (!i && this._weekdaysParse[n].test(t)) return n; } }, _i.weekdaysRegex = function (t) { return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || Qt.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (d(this, "_weekdaysRegex") || (this._weekdaysRegex = Xt), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex); }, _i.weekdaysShortRegex = function (t) { return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || Qt.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (d(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Kt), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex); }, _i.weekdaysMinRegex = function (t) { return this._weekdaysParseExact ? (d(this, "_weekdaysRegex") || Qt.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (d(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Jt), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex); }, _i.isPM = function (t) { return (`${t}`).toLowerCase().charAt(0) === "p"; }, _i.meridiem = function (t, e, i) { return t > 11 ? i ? "pm" : "PM" : i ? "am" : "AM"; }, de("en", { dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal(t) { const e = t % 10; const i = k(t % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"; return t + i; } }), n.lang = S("moment.lang is deprecated. Use moment.locale instead.", de), n.langData = S("moment.langData is deprecated. Use moment.localeData instead.", ce); const Si = Math.abs; function Di(t, e, i, n) { const a = qe(e, i); return t._milliseconds += n * a._milliseconds, t._days += n * a._days, t._months += n * a._months, t._bubble(); } function Ci(t) { return t < 0 ? Math.floor(t) : Math.ceil(t); } function Pi(t) { return 4800 * t / 146097; } function Ti(t) { return 146097 * t / 4800; } function Oi(t) { return function () { return this.as(t); }; } const Ii = Oi("ms"); const Ai = Oi("s"); const Fi = Oi("m"); const Ri = Oi("h"); const Li = Oi("d"); const Wi = Oi("w"); const Yi = Oi("M"); const Ni = Oi("Q"); const zi = Oi("y"); function Vi(t) { return function () { return this.isValid() ? this._data[t] : NaN; }; } const Hi = Vi("milliseconds"); const Ei = Vi("seconds"); const Bi = Vi("minutes"); const ji = Vi("hours"); const Ui = Vi("days"); const Gi = Vi("months"); const qi = Vi("years"); let Zi = Math.round; const $i = {
                ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11,
            }; const Xi = Math.abs; function Ki(t) { return (t > 0) - (t < 0) || +t; } function Ji() { if (!this.isValid()) return this.localeData().invalidDate(); let t; let e; let i = Xi(this._milliseconds) / 1e3; const n = Xi(this._days); let a = Xi(this._months); t = _(i / 60), e = _(t / 60), i %= 60, t %= 60; const r = _(a / 12); const o = a %= 12; const s = n; const l = e; const u = t; const d = i ? i.toFixed(3).replace(/\.?0+$/, "") : ""; const h = this.asSeconds(); if (!h) return "P0D"; const c = h < 0 ? "-" : ""; const f = Ki(this._months) !== Ki(h) ? "-" : ""; const g = Ki(this._days) !== Ki(h) ? "-" : ""; const m = Ki(this._milliseconds) !== Ki(h) ? "-" : ""; return `${c}P${r ? `${f + r}Y` : ""}${o ? `${f + o}M` : ""}${s ? `${g + s}D` : ""}${l || u || d ? "T" : ""}${l ? `${m + l}H` : ""}${u ? `${m + u}M` : ""}${d ? `${m + d}S` : ""}`; } const Qi = We.prototype; return Qi.isValid = function () { return this._isValid; }, Qi.abs = function () { const t = this._data; return this._milliseconds = Si(this._milliseconds), this._days = Si(this._days), this._months = Si(this._months), t.milliseconds = Si(t.milliseconds), t.seconds = Si(t.seconds), t.minutes = Si(t.minutes), t.hours = Si(t.hours), t.months = Si(t.months), t.years = Si(t.years), this; }, Qi.add = function (t, e) { return Di(this, t, e, 1); }, Qi.subtract = function (t, e) { return Di(this, t, e, -1); }, Qi.as = function (t) { if (!this.isValid()) return NaN; let e; let i; const n = this._milliseconds; if ((t = R(t)) === "month" || t === "quarter" || t === "year") switch (e = this._days + n / 864e5, i = this._months + Pi(e), t) { case "month": return i; case "quarter": return i / 3; case "year": return i / 12; } else switch (e = this._days + Math.round(Ti(this._months)), t) { case "week": return e / 7 + n / 6048e5; case "day": return e + n / 864e5; case "hour": return 24 * e + n / 36e5; case "minute": return 1440 * e + n / 6e4; case "second": return 86400 * e + n / 1e3; case "millisecond": return Math.floor(864e5 * e) + n; default: throw new Error(`Unknown unit ${t}`); } }, Qi.asMilliseconds = Ii, Qi.asSeconds = Ai, Qi.asMinutes = Fi, Qi.asHours = Ri, Qi.asDays = Li, Qi.asWeeks = Wi, Qi.asMonths = Yi, Qi.asQuarters = Ni, Qi.asYears = zi, Qi.valueOf = function () { return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * k(this._months / 12) : NaN; }, Qi._bubble = function () { let t; let e; let i; let n; let a; let r = this._milliseconds; let o = this._days; let s = this._months; const l = this._data; return r >= 0 && o >= 0 && s >= 0 || r <= 0 && o <= 0 && s <= 0 || (r += 864e5 * Ci(Ti(s) + o), o = 0, s = 0), l.milliseconds = r % 1e3, t = _(r / 1e3), l.seconds = t % 60, e = _(t / 60), l.minutes = e % 60, i = _(e / 60), l.hours = i % 24, o += _(i / 24), a = _(Pi(o)), s += a, o -= Ci(Ti(a)), n = _(s / 12), s %= 12, l.days = o, l.months = s, l.years = n, this; }, Qi.clone = function () { return qe(this); }, Qi.get = function (t) { return t = R(t), this.isValid() ? this[`${t}s`]() : NaN; }, Qi.milliseconds = Hi, Qi.seconds = Ei, Qi.minutes = Bi, Qi.hours = ji, Qi.days = Ui, Qi.weeks = function () { return _(this.days() / 7); }, Qi.months = Gi, Qi.years = qi, Qi.humanize = function (t) { if (!this.isValid()) return this.localeData().invalidDate(); const e = this.localeData(); let i = (function (t, e, i) { const n = qe(t).abs(); const a = Zi(n.as("s")); const r = Zi(n.as("m")); const o = Zi(n.as("h")); const s = Zi(n.as("d")); const l = Zi(n.as("M")); const u = Zi(n.as("y")); const d = a <= $i.ss && ["s", a] || a < $i.s && ["ss", a] || r <= 1 && ["m"] || r < $i.m && ["mm", r] || o <= 1 && ["h"] || o < $i.h && ["hh", o] || s <= 1 && ["d"] || s < $i.d && ["dd", s] || l <= 1 && ["M"] || l < $i.M && ["MM", l] || u <= 1 && ["y"] || ["yy", u]; return d[2] = e, d[3] = +t > 0, d[4] = i, function (t, e, i, n, a) { return a.relativeTime(e || 1, !!i, t, n); }.apply(null, d); }(this, !t, e)); return t && (i = e.pastFuture(+this, i)), e.postformat(i); }, Qi.toISOString = Ji, Qi.toString = Ji, Qi.toJSON = Ji, Qi.locale = ei, Qi.localeData = ni, Qi.toIsoString = S("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Ji), Qi.lang = ii, B("X", 0, 0, "unix"), B("x", 0, 0, "valueOf"), ut("x", at), ut("X", /[+-]?\d+(\.\d{1,3})?/), ft("X", (t, e, i) => { i._d = new Date(1e3 * parseFloat(t, 10)); }), ft("x", (t, e, i) => { i._d = new Date(k(t)); }), n.version = "2.24.0", e = Ie, n.fn = bi, n.min = function () { return Re("isBefore", [].slice.call(arguments, 0)); }, n.max = function () { return Re("isAfter", [].slice.call(arguments, 0)); }, n.now = function () { return Date.now ? Date.now() : +new Date(); }, n.utc = c, n.unix = function (t) { return Ie(1e3 * t); }, n.months = function (t, e) { return wi(t, e, "months"); }, n.isDate = l, n.locale = de, n.invalid = m, n.duration = qe, n.isMoment = x, n.weekdays = function (t, e, i) { return Mi(t, e, i, "weekdays"); }, n.parseZone = function () { return Ie.apply(null, arguments).parseZone(); }, n.localeData = ce, n.isDuration = Ye, n.monthsShort = function (t, e) { return wi(t, e, "monthsShort"); }, n.weekdaysMin = function (t, e, i) { return Mi(t, e, i, "weekdaysMin"); }, n.defineLocale = he, n.updateLocale = function (t, e) { if (e != null) { let i; let n; let a = re; (n = ue(t)) != null && (a = n._config), e = O(a, e), (i = new I(e)).parentLocale = oe[t], oe[t] = i, de(t); } else oe[t] != null && (oe[t].parentLocale != null ? oe[t] = oe[t].parentLocale : oe[t] != null && delete oe[t]); return oe[t]; }, n.locales = function () { return D(oe); }, n.weekdaysShort = function (t, e, i) { return Mi(t, e, i, "weekdaysShort"); }, n.normalizeUnits = R, n.relativeTimeRounding = function (t) { return void 0 === t ? Zi : typeof t === "function" && (Zi = t, !0); }, n.relativeTimeThreshold = function (t, e) { return void 0 !== $i[t] && (void 0 === e ? $i[t] : ($i[t] = e, t === "s" && ($i.ss = e - 1), !0)); }, n.calendarFormat = function (t, e) { const i = t.diff(e, "days", !0); return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse"; }, n.prototype = bi, n.HTML5_FMT = {
                DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM",
            }, n;
        }());
    }(tn = { exports: {} }, tn.exports)), tn.exports); const an = {
        datetime: "MMM D, YYYY, h:mm:ss a", millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY",
    }; si._date.override(typeof nn === "function" ? {
        _id: "moment", formats() { return an; }, parse(t, e) { return typeof t === "string" && typeof e === "string" ? t = nn(t, e) : t instanceof nn || (t = nn(t)), t.isValid() ? t.valueOf() : null; }, format(t, e) { return nn(t).format(e); }, add(t, e, i) { return nn(t).add(e, i).valueOf(); }, diff(t, e, i) { return nn.duration(nn(t).diff(nn(e))).as(i); }, startOf(t, e, i) { return t = nn(t), e === "isoWeek" ? t.isoWeekday(i).valueOf() : t.startOf(e).valueOf(); }, endOf(t, e) { return nn(t).endOf(e).valueOf(); }, _create(t) { return nn(t); },
    } : {}), ot._set("global", { plugins: { filler: { propagate: !0 } } }); const rn = { dataset(t) { const e = t.fill; const i = t.chart; const n = i.getDatasetMeta(e); const a = n && i.isDatasetVisible(e) && n.dataset._children || []; const r = a.length || 0; return r ? function (t, e) { return e < r && a[e]._view || null; } : null; }, boundary(t) { const e = t.boundary; const i = e ? e.x : null; const n = e ? e.y : null; return function (t) { return { x: i === null ? t.x : i, y: n === null ? t.y : n }; }; } }; function on(t, e, i) { let n; const a = t._model || {}; let r = a.fill; if (void 0 === r && (r = !!a.backgroundColor), !1 === r || r === null) return !1; if (!0 === r) return "origin"; if (n = parseFloat(r, 10), isFinite(n) && Math.floor(n) === n) return r[0] !== "-" && r[0] !== "+" || (n = e + n), !(n === e || n < 0 || n >= i) && n; switch (r) { case "bottom": return "start"; case "top": return "end"; case "zero": return "origin"; case "origin": case "start": case "end": return r; default: return !1; } } function sn(t) { let e; const i = t.el._model || {}; const n = t.el._scale || {}; const a = t.fill; let r = null; if (isFinite(a)) return null; if (a === "start" ? r = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : a === "end" ? r = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? r = i.scaleZero : n.getBasePosition ? r = n.getBasePosition() : n.getBasePixel && (r = n.getBasePixel()), r != null) { if (void 0 !== r.x && void 0 !== r.y) return r; if (ut.isFinite(r)) return { x: (e = n.isHorizontal()) ? r : null, y: e ? null : r }; } return null; } function ln(t, e, i) { let n; let a = t[e].fill; const r = [e]; if (!i) return a; for (;!1 !== a && r.indexOf(a) === -1;) { if (!isFinite(a)) return a; if (!(n = t[a])) return !1; if (n.visible) return a; r.push(a), a = n.fill; } return !1; } function un(t) { const e = t.fill; let i = "dataset"; return !1 === e ? null : (isFinite(e) || (i = "boundary"), rn[i](t)); } function dn(t) { return t && !t.skip; } function hn(t, e, i, n, a) { let r; if (n && a) { for (t.moveTo(e[0].x, e[0].y), r = 1; r < n; ++r)ut.canvas.lineTo(t, e[r - 1], e[r]); for (t.lineTo(i[a - 1].x, i[a - 1].y), r = a - 1; r > 0; --r)ut.canvas.lineTo(t, i[r], i[r - 1], !0); } } const cn = {
        id: "filler",
        afterDatasetsUpdate(t, e) {
            let i; let n; let a; let r; const o = (t.data.datasets || []).length; const s = e.propagate; const l = []; for (n = 0; n < o; ++n) {
                r = null, (a = (i = t.getDatasetMeta(n)).dataset) && a._model && a instanceof Nt.Line && (r = {
                    visible: t.isDatasetVisible(n), fill: on(a, n, o), chart: t, el: a,
                }), i.$filler = r, l.push(r);
            } for (n = 0; n < o; ++n)(r = l[n]) && (r.fill = ln(l, n, s), r.boundary = sn(r), r.mapper = un(r));
        },
        beforeDatasetDraw(t, e) { const i = e.meta.$filler; if (i) { const n = t.ctx; const a = i.el; const r = a._view; const o = a._children || []; const s = i.mapper; const l = r.backgroundColor || ot.global.defaultColor; s && l && o.length && (ut.canvas.clipArea(n, t.chartArea), (function (t, e, i, n, a, r) { let o; let s; let l; let u; let d; let h; let c; const f = e.length; const g = n.spanGaps; let m = []; let p = []; let v = 0; let y = 0; for (t.beginPath(), o = 0, s = f + !!r; o < s; ++o)d = i(u = e[l = o % f]._view, l, n), h = dn(u), c = dn(d), h && c ? (v = m.push(u), y = p.push(d)) : v && y && (g ? (h && m.push(u), c && p.push(d)) : (hn(t, m, p, v, y), v = y = 0, m = [], p = [])); hn(t, m, p, v, y), t.closePath(), t.fillStyle = a, t.fill(); }(n, o, s, r, l, a._loop)), ut.canvas.unclipArea(n)); } },
    }; const fn = ut.noop; const gn = ut.valueOrDefault; function mn(t, e) { return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth; }ot._set("global", {
        legend: {
            display: !0,
            position: "top",
            fullWidth: !0,
            reverse: !1,
            weight: 1e3,
            onClick(t, e) { const i = e.datasetIndex; const n = this.chart; const a = n.getDatasetMeta(i); a.hidden = a.hidden === null ? !n.data.datasets[i].hidden : null, n.update(); },
            onHover: null,
            onLeave: null,
            labels: {
                boxWidth: 40,
                padding: 10,
                generateLabels(t) {
                    const e = t.data; return ut.isArray(e.datasets) ? e.datasets.map((e, i) => ({
                        text: e.label, fillStyle: ut.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: e.borderCapStyle, lineDash: e.borderDash, lineDashOffset: e.borderDashOffset, lineJoin: e.borderJoinStyle, lineWidth: e.borderWidth, strokeStyle: e.borderColor, pointStyle: e.pointStyle, datasetIndex: i,
                    }), this) : [];
                },
            },
        },
        legendCallback(t) { const e = []; e.push(`<ul class="${t.id}-legend">`); for (let i = 0; i < t.data.datasets.length; i++)e.push(`<li><span style="background-color:${t.data.datasets[i].backgroundColor}"></span>`), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>"); return e.push("</ul>"), e.join(""); },
    }); const pn = gt.extend({
        initialize(t) { ut.extend(this, t), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1; },
        beforeUpdate: fn,
        update(t, e, i) { const n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize; },
        afterUpdate: fn,
        beforeSetDimensions: fn,
        setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; },
        afterSetDimensions: fn,
        beforeBuildLabels: fn,
        buildLabels() { const t = this; const e = t.options.labels || {}; let i = ut.callback(e.generateLabels, [t.chart], t) || []; e.filter && (i = i.filter((i) => e.filter(i, t.chart.data))), t.options.reverse && i.reverse(), t.legendItems = i; },
        afterBuildLabels: fn,
        beforeFit: fn,
        fit() {
            const t = this; const e = t.options; const i = e.labels; const n = e.display; const a = t.ctx; const r = ut.options._parseFont(i); const o = r.size; const s = t.legendHitBoxes = []; const l = t.minSize; const u = t.isHorizontal(); if (u ? (l.width = t.maxWidth, l.height = n ? 10 : 0) : (l.width = n ? 10 : 0, l.height = t.maxHeight), n) {
                if (a.font = r.string, u) {
                    const d = t.lineWidths = [0]; let h = 0; a.textAlign = "left", a.textBaseline = "top", ut.each(t.legendItems, (t, e) => {
                        const n = mn(i, o) + o / 2 + a.measureText(t.text).width; (e === 0 || d[d.length - 1] + n + i.padding > l.width) && (h += o + i.padding, d[d.length - (e > 0 ? 0 : 1)] = i.padding), s[e] = {
                            left: 0, top: 0, width: n, height: o,
                        }, d[d.length - 1] += n + i.padding;
                    }), l.height += h;
                } else {
                    const c = i.padding; const f = t.columnWidths = []; let g = i.padding; let m = 0; let p = 0; const v = o + c; ut.each(t.legendItems, (t, e) => {
                        const n = mn(i, o) + o / 2 + a.measureText(t.text).width; e > 0 && p + v > l.height - c && (g += m + i.padding, f.push(m), m = 0, p = 0), m = Math.max(m, n), p += v, s[e] = {
                            left: 0, top: 0, width: n, height: o,
                        };
                    }), g += m, f.push(m), l.width += g;
                }
            }t.width = l.width, t.height = l.height;
        },
        afterFit: fn,
        isHorizontal() { return this.options.position === "top" || this.options.position === "bottom"; },
        draw() { const t = this; const e = t.options; const i = e.labels; const n = ot.global; const a = n.defaultColor; const r = n.elements.line; const o = t.width; const s = t.lineWidths; if (e.display) { let l; const u = t.ctx; const d = gn(i.fontColor, n.defaultFontColor); const h = ut.options._parseFont(i); const c = h.size; u.textAlign = "left", u.textBaseline = "middle", u.lineWidth = 0.5, u.strokeStyle = d, u.fillStyle = d, u.font = h.string; const f = mn(i, c); const g = t.legendHitBoxes; const m = t.isHorizontal(); l = m ? { x: t.left + (o - s[0]) / 2 + i.padding, y: t.top + i.padding, line: 0 } : { x: t.left + i.padding, y: t.top + i.padding, line: 0 }; const p = c + i.padding; ut.each(t.legendItems, (n, d) => { const h = u.measureText(n.text).width; const v = f + c / 2 + h; let y = l.x; let b = l.y; m ? d > 0 && y + v + i.padding > t.left + t.minSize.width && (b = l.y += p, l.line++, y = l.x = t.left + (o - s[l.line]) / 2 + i.padding) : d > 0 && b + p > t.top + t.minSize.height && (y = l.x = y + t.columnWidths[l.line] + i.padding, b = l.y = t.top + i.padding, l.line++), (function (t, i, n) { if (!(isNaN(f) || f <= 0)) { u.save(); const o = gn(n.lineWidth, r.borderWidth); if (u.fillStyle = gn(n.fillStyle, a), u.lineCap = gn(n.lineCap, r.borderCapStyle), u.lineDashOffset = gn(n.lineDashOffset, r.borderDashOffset), u.lineJoin = gn(n.lineJoin, r.borderJoinStyle), u.lineWidth = o, u.strokeStyle = gn(n.strokeStyle, a), u.setLineDash && u.setLineDash(gn(n.lineDash, r.borderDash)), e.labels && e.labels.usePointStyle) { const s = f * Math.SQRT2 / 2; const l = t + f / 2; const d = i + c / 2; ut.canvas.drawPoint(u, n.pointStyle, s, l, d); } else o !== 0 && u.strokeRect(t, i, f, c), u.fillRect(t, i, f, c); u.restore(); } }(y, b, n)), g[d].left = y, g[d].top = b, (function (t, e, i, n) { const a = c / 2; const r = f + a + t; const o = e + a; u.fillText(i.text, r, o), i.hidden && (u.beginPath(), u.lineWidth = 2, u.moveTo(r, o), u.lineTo(r + n, o), u.stroke()); }(y, b, n, h)), m ? l.x += v + i.padding : l.y += p; }); } },
        _getLegendItemAt(t, e) { let i; let n; let a; const r = this; if (t >= r.left && t <= r.right && e >= r.top && e <= r.bottom) for (a = r.legendHitBoxes, i = 0; i < a.length; ++i) if (t >= (n = a[i]).left && t <= n.left + n.width && e >= n.top && e <= n.top + n.height) return r.legendItems[i]; return null; },
        handleEvent(t) { let e; const i = this; const n = i.options; const a = t.type === "mouseup" ? "click" : t.type; if (a === "mousemove") { if (!n.onHover && !n.onLeave) return; } else { if (a !== "click") return; if (!n.onClick) return; }e = i._getLegendItemAt(t.x, t.y), a === "click" ? e && n.onClick && n.onClick.call(i, t.native, e) : (n.onLeave && e !== i._hoveredItem && (i._hoveredItem && n.onLeave.call(i, t.native, i._hoveredItem), i._hoveredItem = e), n.onHover && e && n.onHover.call(i, t.native, e)); },
    }); function vn(t, e) { const i = new pn({ ctx: t.ctx, options: e, chart: t }); xe.configure(t, i, e), xe.addBox(t, i), t.legend = i; } const yn = {
        id: "legend", _element: pn, beforeInit(t) { const e = t.options.legend; e && vn(t, e); }, beforeUpdate(t) { const e = t.options.legend; const i = t.legend; e ? (ut.mergeIf(e, ot.global.legend), i ? (xe.configure(t, i, e), i.options = e) : vn(t, e)) : i && (xe.removeBox(t, i), delete t.legend); }, afterEvent(t, e) { const i = t.legend; i && i.handleEvent(e); },
    }; const bn = ut.noop; ot._set("global", {
        title: {
            display: !1, fontStyle: "bold", fullWidth: !0, padding: 10, position: "top", text: "", weight: 2e3,
        },
    }); const xn = gt.extend({
        initialize(t) { ut.extend(this, t), this.legendHitBoxes = []; }, beforeUpdate: bn, update(t, e, i) { const n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize; }, afterUpdate: bn, beforeSetDimensions: bn, setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; }, afterSetDimensions: bn, beforeBuildLabels: bn, buildLabels: bn, afterBuildLabels: bn, beforeFit: bn, fit() { const t = this; const e = t.options; const i = e.display; const n = t.minSize; const a = ut.isArray(e.text) ? e.text.length : 1; const r = ut.options._parseFont(e); const o = i ? a * r.lineHeight + 2 * e.padding : 0; t.isHorizontal() ? (n.width = t.maxWidth, n.height = o) : (n.width = o, n.height = t.maxHeight), t.width = n.width, t.height = n.height; }, afterFit: bn, isHorizontal() { const t = this.options.position; return t === "top" || t === "bottom"; }, draw() { const t = this; const e = t.ctx; const i = t.options; if (i.display) { let n; let a; let r; const o = ut.options._parseFont(i); const s = o.lineHeight; const l = s / 2 + i.padding; let u = 0; const d = t.top; const h = t.left; const c = t.bottom; const f = t.right; e.fillStyle = ut.valueOrDefault(i.fontColor, ot.global.defaultFontColor), e.font = o.string, t.isHorizontal() ? (a = h + (f - h) / 2, r = d + l, n = f - h) : (a = i.position === "left" ? h + l : f - l, r = d + (c - d) / 2, n = c - d, u = Math.PI * (i.position === "left" ? -0.5 : 0.5)), e.save(), e.translate(a, r), e.rotate(u), e.textAlign = "center", e.textBaseline = "middle"; const g = i.text; if (ut.isArray(g)) for (let m = 0, p = 0; p < g.length; ++p)e.fillText(g[p], 0, m, n), m += s; else e.fillText(g, 0, 0, n); e.restore(); } },
    }); function _n(t, e) { const i = new xn({ ctx: t.ctx, options: e, chart: t }); xe.configure(t, i, e), xe.addBox(t, i), t.titleBlock = i; } const kn = {}; const wn = cn; const Mn = yn; const Sn = {
        id: "title", _element: xn, beforeInit(t) { const e = t.options.title; e && _n(t, e); }, beforeUpdate(t) { const e = t.options.title; const i = t.titleBlock; e ? (ut.mergeIf(e, ot.global.title), i ? (xe.configure(t, i, e), i.options = e) : _n(t, e)) : i && (xe.removeBox(t, i), delete t.titleBlock); },
    }; for (const Dn in kn.filler = wn, kn.legend = Mn, kn.title = Sn, ai.helpers = ut, (function () { function t(t, e, i) { let n; return typeof t === "string" ? (n = parseInt(t, 10), t.indexOf("%") !== -1 && (n = n / 100 * e.parentNode[i])) : n = t, n; } function e(t) { return t != null && t !== "none"; } function i(i, n, a) { const r = document.defaultView; const o = ut._getParentNode(i); const s = r.getComputedStyle(i)[n]; const l = r.getComputedStyle(o)[n]; const u = e(s); const d = e(l); const h = Number.POSITIVE_INFINITY; return u || d ? Math.min(u ? t(s, i, a) : h, d ? t(l, o, a) : h) : "none"; }ut.where = function (t, e) { if (ut.isArray(t) && Array.prototype.filter) return t.filter(e); const i = []; return ut.each(t, (t) => { e(t) && i.push(t); }), i; }, ut.findIndex = Array.prototype.findIndex ? function (t, e, i) { return t.findIndex(e, i); } : function (t, e, i) { i = void 0 === i ? t : i; for (let n = 0, a = t.length; n < a; ++n) if (e.call(i, t[n], n, t)) return n; return -1; }, ut.findNextWhere = function (t, e, i) { ut.isNullOrUndef(i) && (i = -1); for (let n = i + 1; n < t.length; n++) { const a = t[n]; if (e(a)) return a; } }, ut.findPreviousWhere = function (t, e, i) { ut.isNullOrUndef(i) && (i = t.length); for (let n = i - 1; n >= 0; n--) { const a = t[n]; if (e(a)) return a; } }, ut.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t); }, ut.almostEquals = function (t, e, i) { return Math.abs(t - e) < i; }, ut.almostWhole = function (t, e) { const i = Math.round(t); return i - e < t && i + e > t; }, ut.max = function (t) { return t.reduce((t, e) => (isNaN(e) ? t : Math.max(t, e)), Number.NEGATIVE_INFINITY); }, ut.min = function (t) { return t.reduce((t, e) => (isNaN(e) ? t : Math.min(t, e)), Number.POSITIVE_INFINITY); }, ut.sign = Math.sign ? function (t) { return Math.sign(t); } : function (t) { return (t = +t) == 0 || isNaN(t) ? t : t > 0 ? 1 : -1; }, ut.log10 = Math.log10 ? function (t) { return Math.log10(t); } : function (t) { const e = Math.log(t) * Math.LOG10E; const i = Math.round(e); return t === Math.pow(10, i) ? i : e; }, ut.toRadians = function (t) { return t * (Math.PI / 180); }, ut.toDegrees = function (t) { return t * (180 / Math.PI); }, ut._decimalPlaces = function (t) { if (ut.isFinite(t)) { for (var e = 1, i = 0; Math.round(t * e) / e !== t;)e *= 10, i++; return i; } }, ut.getAngleFromPoint = function (t, e) { const i = e.x - t.x; const n = e.y - t.y; const a = Math.sqrt(i * i + n * n); let r = Math.atan2(n, i); return r < -0.5 * Math.PI && (r += 2 * Math.PI), { angle: r, distance: a }; }, ut.distanceBetweenPoints = function (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)); }, ut.aliasPixel = function (t) { return t % 2 == 0 ? 0 : 0.5; }, ut._alignPixel = function (t, e, i) { const n = t.currentDevicePixelRatio; const a = i / 2; return Math.round((e - a) * n) / n + a; }, ut.splineCurve = function (t, e, i, n) { const a = t.skip ? e : t; const r = e; const o = i.skip ? e : i; const s = Math.sqrt(Math.pow(r.x - a.x, 2) + Math.pow(r.y - a.y, 2)); const l = Math.sqrt(Math.pow(o.x - r.x, 2) + Math.pow(o.y - r.y, 2)); let u = s / (s + l); let d = l / (s + l); const h = n * (u = isNaN(u) ? 0 : u); const c = n * (d = isNaN(d) ? 0 : d); return { previous: { x: r.x - h * (o.x - a.x), y: r.y - h * (o.y - a.y) }, next: { x: r.x + c * (o.x - a.x), y: r.y + c * (o.y - a.y) } }; }, ut.EPSILON = Number.EPSILON || 1e-14, ut.splineCurveMonotone = function (t) { let e; let i; let n; let a; let r; let o; let s; let l; let u; const d = (t || []).map((t) => ({ model: t._model, deltaK: 0, mK: 0 })); const h = d.length; for (e = 0; e < h; ++e) if (!(n = d[e]).model.skip) { if (i = e > 0 ? d[e - 1] : null, (a = e < h - 1 ? d[e + 1] : null) && !a.model.skip) { const c = a.model.x - n.model.x; n.deltaK = c !== 0 ? (a.model.y - n.model.y) / c : 0; }!i || i.model.skip ? n.mK = n.deltaK : !a || a.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2; } for (e = 0; e < h - 1; ++e)n = d[e], a = d[e + 1], n.model.skip || a.model.skip || (ut.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = a.mK = 0 : (r = n.mK / n.deltaK, o = a.mK / n.deltaK, (l = Math.pow(r, 2) + Math.pow(o, 2)) <= 9 || (s = 3 / Math.sqrt(l), n.mK = r * s * n.deltaK, a.mK = o * s * n.deltaK))); for (e = 0; e < h; ++e)(n = d[e]).model.skip || (i = e > 0 ? d[e - 1] : null, a = e < h - 1 ? d[e + 1] : null, i && !i.model.skip && (u = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - u, n.model.controlPointPreviousY = n.model.y - u * n.mK), a && !a.model.skip && (u = (a.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + u, n.model.controlPointNextY = n.model.y + u * n.mK)); }, ut.nextItem = function (t, e, i) { return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1]; }, ut.previousItem = function (t, e, i) { return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1]; }, ut.niceNum = function (t, e) { const i = Math.floor(ut.log10(t)); const n = t / Math.pow(10, i); return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, i); }, ut.requestAnimFrame = typeof window === "undefined" ? function (t) { t(); } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60); }, ut.getRelativePosition = function (t, e) { let i; let n; const a = t.originalEvent || t; const r = t.target || t.srcElement; const o = r.getBoundingClientRect(); const s = a.touches; s && s.length > 0 ? (i = s[0].clientX, n = s[0].clientY) : (i = a.clientX, n = a.clientY); const l = parseFloat(ut.getStyle(r, "padding-left")); const u = parseFloat(ut.getStyle(r, "padding-top")); const d = parseFloat(ut.getStyle(r, "padding-right")); const h = parseFloat(ut.getStyle(r, "padding-bottom")); const c = o.right - o.left - l - d; const f = o.bottom - o.top - u - h; return { x: i = Math.round((i - o.left - l) / c * r.width / e.currentDevicePixelRatio), y: n = Math.round((n - o.top - u) / f * r.height / e.currentDevicePixelRatio) }; }, ut.getConstraintWidth = function (t) { return i(t, "max-width", "clientWidth"); }, ut.getConstraintHeight = function (t) { return i(t, "max-height", "clientHeight"); }, ut._calculatePadding = function (t, e, i) { return (e = ut.getStyle(t, e)).indexOf("%") > -1 ? i * parseInt(e, 10) / 100 : parseInt(e, 10); }, ut._getParentNode = function (t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e; }, ut.getMaximumWidth = function (t) { const e = ut._getParentNode(t); if (!e) return t.clientWidth; const i = e.clientWidth; const n = i - ut._calculatePadding(e, "padding-left", i) - ut._calculatePadding(e, "padding-right", i); const a = ut.getConstraintWidth(t); return isNaN(a) ? n : Math.min(n, a); }, ut.getMaximumHeight = function (t) { const e = ut._getParentNode(t); if (!e) return t.clientHeight; const i = e.clientHeight; const n = i - ut._calculatePadding(e, "padding-top", i) - ut._calculatePadding(e, "padding-bottom", i); const a = ut.getConstraintHeight(t); return isNaN(a) ? n : Math.min(n, a); }, ut.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e); }, ut.retinaScale = function (t, e) { const i = t.currentDevicePixelRatio = e || typeof window !== "undefined" && window.devicePixelRatio || 1; if (i !== 1) { const n = t.canvas; const a = t.height; const r = t.width; n.height = a * i, n.width = r * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = `${a}px`, n.style.width = `${r}px`); } }, ut.fontString = function (t, e, i) { return `${e} ${t}px ${i}`; }, ut.longestText = function (t, e, i, n) { let a = (n = n || {}).data = n.data || {}; let r = n.garbageCollect = n.garbageCollect || []; n.font !== e && (a = n.data = {}, r = n.garbageCollect = [], n.font = e), t.font = e; let o = 0; ut.each(i, (e) => { e != null && !0 !== ut.isArray(e) ? o = ut.measureText(t, a, r, o, e) : ut.isArray(e) && ut.each(e, (e) => { e == null || ut.isArray(e) || (o = ut.measureText(t, a, r, o, e)); }); }); const s = r.length / 2; if (s > i.length) { for (let l = 0; l < s; l++) delete a[r[l]]; r.splice(0, s); } return o; }, ut.measureText = function (t, e, i, n, a) { let r = e[a]; return r || (r = e[a] = t.measureText(a).width, i.push(a)), r > n && (n = r), n; }, ut.numberOfLabelLines = function (t) { let e = 1; return ut.each(t, (t) => { ut.isArray(t) && t.length > e && (e = t.length); }), e; }, ut.color = G ? function (t) { return t instanceof CanvasGradient && (t = ot.global.defaultColor), G(t); } : function (t) { return console.error("Color.js not found!"), t; }, ut.getHoverColor = function (t) { return t instanceof CanvasPattern || t instanceof CanvasGradient ? t : ut.color(t).saturate(0.5).darken(0.1).rgbString(); }; }()), ai._adapters = si, ai.Animation = pt, ai.animationService = vt, ai.controllers = ue, ai.DatasetController = kt, ai.defaults = ot, ai.Element = gt, ai.elements = Nt, ai.Interaction = pe, ai.layouts = xe, ai.platform = Ve, ai.plugins = He, ai.Scale = fi, ai.scaleService = Ee, ai.Ticks = li, ai.Tooltip = Je, ai.helpers.each(en, (t, e) => { ai.scaleService.registerScaleType(e, t, t._defaults); }), kn)kn.hasOwnProperty(Dn) && ai.plugins.register(kn[Dn]); ai.platform.initialize(); const Cn = ai; return typeof window !== "undefined" && (window.Chart = ai), ai.Chart = ai, ai.Legend = kn.legend._element, ai.Title = kn.title._element, ai.pluginService = ai.plugins, ai.PluginBase = ai.Element.extend({}), ai.canvasHelpers = ai.helpers.canvas, ai.layoutService = ai.layouts, ai.LinearScaleBase = yi, ai.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], (t) => { ai[t] = function (e, i) { return new ai(e, ai.helpers.merge(i || {}, { type: t.charAt(0).toLowerCase() + t.slice(1) })); }; }), Cn;
}));
